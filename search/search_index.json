{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"KudoJS Documentation","text":"<p>KudoJS is a small utility library with a collection of popular Algebraic Data Types and Helper functions to help you write code in a functional programming style in Javascript.</p>"},{"location":"#overview","title":"Overview","text":"<ul> <li>Helper Functions - Documentation for all utility functions in the <code>kudoJS.*</code> namespace</li> <li>ADT Documentation - Detailed documentation for each ADT implementation</li> </ul>"},{"location":"#algebraic-data-types-adts","title":"Algebraic Data Types (ADTs)","text":"<p>ADTs under the kudoJS.* namespace. All of the data types are compatible with the Fantasy Land Specifications</p> <ul> <li><code>kudoJS.Identity</code> - Type for handling pure values</li> <li><code>kudoJS.Pair</code> - Tuple type for handling two values</li> <li><code>kudoJS.Maybe</code> - Type for handling nullable values safely</li> <li><code>kudoJS.Either</code> - Type for handling branching and error cases</li> <li><code>kudoJS.Task</code> - Type for handling asynchronous computations</li> <li><code>kudoJS.Reader</code> - Type for handling dependency injection</li> <li><code>kudoJS.State</code> - Type for handling stateful computations</li> </ul>"},{"location":"#adt-reference","title":"ADT Reference","text":"ADT Constructors Static Methods Instance Methods <code>Identity</code> <code>Identity</code>, <code>of</code> <code>equals</code>, <code>concat</code>,<code>ap</code>, <code>getValue</code>, <code>map</code>,<code>chain</code>, <code>toString</code> <code>Pair</code> <code>Pair</code>, <code>of</code> <code>equals</code>, <code>concat</code>, <code>fst</code>, <code>snd</code>, <code>ap</code>, <code>getValue</code>, <code>map</code>, <code>bimap</code>, <code>chain</code>, <code>swap</code>, <code>toString</code> <code>Maybe</code> <code>of</code>, <code>Just</code>, <code>Nothing</code>, <code>zero</code>, <code>fromNullable</code>, <code>withDefault</code> <code>catMaybes</code>, <code>isNothing</code>, <code>isJust</code> <code>equals</code>, <code>ap</code>, <code>alt</code>, <code>map</code>, <code>chain</code>, <code>toString</code>, <code>getValue</code>, <code>isNothing</code>, <code>isJust</code> <code>Either</code> <code>of</code>, <code>Left</code>, <code>Right</code>, <code>fromNullable</code>, <code>withDefault</code> <code>try</code>, <code>isLeft</code>, <code>isRight</code> <code>equals</code>, <code>ap</code>, <code>getValue</code>, <code>map</code>, <code>bimap</code>, <code>chain</code>, <code>swap</code>, <code>toString</code>, <code>isLeft</code>, <code>isRight</code> <code>Task</code> <code>Task</code>, <code>of</code>, <code>rejected</code> <code>fork</code>, <code>concat</code>, <code>ap</code>, <code>getValue</code>, <code>map</code>, <code>chain</code>, <code>toPromise</code>, <code>toString</code> <code>Reader</code> <code>Reader</code>, <code>of</code>, <code>ask</code> <code>runWith</code>, <code>ap</code>, <code>getValue</code>, <code>map</code>, <code>chain</code>, <code>toString</code> <code>State</code> <code>State</code>, <code>of</code>, <code>get</code>, <code>put</code> <code>runWith</code>, <code>execWith</code>, <code>evalWith</code>, <code>ap</code>, <code>getValue</code>, <code>map</code>, <code>chain</code>, <code>toString</code>"},{"location":"either/","title":"Either","text":""},{"location":"either/#either","title":"Either","text":"<p><code>Either</code> is a monad and can be used as a generic structure for a type with two possibilities: a Left a or a Right b. It represents the logical disjunction between <code>a</code> and <code>b</code>.</p> <p>A common use of this structure is to handle error cases and situations where a computation might fail, while also providing additional information about the failure. It is used to represent a value that is either correct or an error. By convention, the Left constructor is used to hold an error value, and the Right constructor is used to hold a correct value. This structure forces explicit handling of failures and avoids the problems associated with throwing exceptions.</p> <p>Implements: <code>BiFunctor</code>, <code>Monad</code>, <code>Setoid</code></p> <ul> <li>Either<ul> <li>Either.of(v)</li> <li>Either.Right(v)</li> <li>Either.Left(v)</li> <li>Either.fromNullable(v)</li> <li>Either.withDefault(def, v)</li> <li>Either.swap()</li> <li>Either.try(f)</li> <li>Either.bimap(e, fl, fr)</li> <li>Either.isLeft(e)</li> <li>Either.isRight(e)</li> <li>Either.equals(n)</li> <li>Either.map(f)</li> <li>Either.bimap(fl, fr)</li> <li>Either.chain(f)</li> <li>Either.swap()</li> <li>Either.isLeft()</li> <li>Either.isRight()</li> <li>Either.ap(j)</li> <li>Either.getValue()</li> </ul> </li> </ul> <p></p>"},{"location":"either/#eitherofv","title":"Either.of(v)","text":"<p>Creates a Right <code>Either</code>.</p> Param Type Description v <code>any</code> Value <p></p>"},{"location":"either/#eitherrightv","title":"Either.Right(v)","text":"<p>Creates a Right <code>Either</code>.</p> Param Type Description v <code>any</code> Value <p></p>"},{"location":"either/#eitherleftv","title":"Either.Left(v)","text":"<p>Creates a Left <code>Either</code>.</p> Param Type Description v <code>any</code> Value <p></p>"},{"location":"either/#eitherfromnullablev","title":"Either.fromNullable(v)","text":"<p>Creates a Right if the value is not <code>null</code> or <code>undefined</code>; otherwise, creates a Left.</p> Param Type Description v <code>any</code> Value <p></p>"},{"location":"either/#eitherwithdefaultdef-v","title":"Either.withDefault(def, v)","text":"<p>Creates a Right if the value <code>v</code> is not <code>null</code> or <code>undefined</code>; otherwise, creates a Right with the default value <code>def</code>.</p> Param Type Description def <code>any</code> Default value v <code>any</code> Value <p></p>"},{"location":"either/#eitherswap","title":"Either.swap()","text":"<p>Swaps the Left and Right elements of the current <code>Either</code>.</p> <p></p>"},{"location":"either/#eithertryf","title":"Either.try(f)","text":"<p>Executes the passed function that may throw and converts it to an <code>Either</code> type.</p> Param Type Description f <code>function</code> A function that may throw an error <p></p>"},{"location":"either/#eitherbimape-fl-fr","title":"Either.bimap(e, fl, fr)","text":"<p>A static method that applies <code>fl</code> to the Left element or <code>fr</code> to the Right element of the current <code>Either</code>.</p> Param Type Description e <code>any</code> <code>Either</code> type fl <code>function</code> Function to be applied on the Left element fr <code>function</code> Function to be applied on the Right element <p></p>"},{"location":"either/#eitherislefte","title":"Either.isLeft(e)","text":"<p>A static method that returns <code>true</code> if the passed <code>Either</code> is a Left.</p> Param Type Description e <code>any</code> <code>Either</code> type <p></p>"},{"location":"either/#eitherisrighte","title":"Either.isRight(e)","text":"<p>A static method that returns <code>true</code> if the passed <code>Either</code> is a Right.</p> Param Type Description e <code>any</code> <code>Either</code> type <p></p>"},{"location":"either/#eitherequalsn","title":"Either.equals(n)","text":"<p>Returns <code>true</code> if the current and the passed element are of <code>Either</code> type with the same value.</p> Param Type Description n <code>any</code> Any value of type <code>Setoid</code> <p></p>"},{"location":"either/#eithermapf","title":"Either.map(f)","text":"<p>Applies the passed function to the value of the current <code>Either</code> if it is a Right.</p> Param Type Description f <code>function</code> Function <p></p>"},{"location":"either/#eitherbimapfl-fr","title":"Either.bimap(fl, fr)","text":"<p>Applies <code>fl</code> to the Left element or <code>fr</code> to the Right element of the current <code>Either</code>.</p> Param Type Description fl <code>function</code> Function to be applied on the Left element fr <code>function</code> Function to be applied on the Right element <p></p>"},{"location":"either/#eitherchainf","title":"Either.chain(f)","text":"<p>An instance method that can chain together many computations that return an <code>Either</code> type.</p> Param Type Description f <code>function</code> Function that returns another <code>Either</code> <p></p>"},{"location":"either/#eitherswap_1","title":"Either.swap()","text":"<p>Swaps the Left and Right elements of the current <code>Either</code>.</p> <p></p>"},{"location":"either/#eitherisleft","title":"Either.isLeft()","text":"<p>An instance method that returns <code>true</code> if the current <code>Either</code> is a Left.</p> <p></p>"},{"location":"either/#eitherisright","title":"Either.isRight()","text":"<p>An instance method that returns <code>true</code> if the current <code>Either</code> is a Right.</p> <p></p>"},{"location":"either/#eitherapj","title":"Either.ap(j)","text":"<p>Applies the function inside the passed <code>Either</code> to the current <code>Either</code> if it is a Right.</p> Param Type Description j <code>any</code> <code>Either</code> with a function <p></p>"},{"location":"either/#eithergetvalue","title":"Either.getValue()","text":"<p>Gets the value inside the <code>Either</code>.</p>"},{"location":"helper-functions/","title":"KudoJS Helper Functions","text":"<p>These are the functions under the <code>kudoJS.*</code> namespace:</p> <ul> <li>KudoJS Helper Functions<ul> <li><code>kudoJS.id</code></li> <li><code>kudoJS.once</code></li> <li><code>kudoJS.curry</code></li> <li><code>kudoJS.ocurry</code></li> <li><code>kudoJS.compose</code></li> <li><code>kudoJS.constant</code></li> <li><code>kudoJS.fmap</code></li> <li><code>kudoJS.assoc</code></li> <li><code>kudoJS.bimap</code></li> <li><code>kudoJS.chain</code></li> <li><code>kudoJS.caseOf</code></li> <li><code>kudoJS.liftAn</code></li> <li><code>kudoJS.liftA2</code></li> <li><code>kudoJS.liftA3</code></li> <li><code>kudoJS.liftA4</code></li> <li><code>kudoJS.liftA5</code></li> <li><code>kudoJS.when</code></li> <li><code>kudoJS.prop</code></li> <li><code>kudoJS.pick</code></li> <li><code>kudoJS.eitherToMaybe</code></li> <li><code>kudoJS.maybeToEither</code></li> </ul> </li> </ul>"},{"location":"helper-functions/#kudojsid","title":"<code>kudoJS.id</code>","text":"<p>The identity function. It returns the value given to it.</p> <p><code>id(x: any): any</code></p> Param Type Description x <code>*</code> Any"},{"location":"helper-functions/#kudojsonce","title":"<code>kudoJS.once</code>","text":"<p>Returns a function that, when called, fires the passed function only once.</p> <p><code>once(f: Function): Function</code></p> Param Type Description f <code>function</code> Function to be called once"},{"location":"helper-functions/#kudojscurry","title":"<code>kudoJS.curry</code>","text":"<p>Returns a curried equivalent of the provided function.</p> <p><code>curry(fn: Function): Function</code></p> Param Type Description fn <code>function</code> Function to be curried"},{"location":"helper-functions/#kudojsocurry","title":"<code>kudoJS.ocurry</code>","text":"<p>Returns a curried equivalent of the provided function, which will accept named arguments in any order.</p> <p><code>ocurry(fn: Function, args: Array&lt;string&gt;): Function</code></p> Param Type Description fn <code>function</code> Function to be curried that accepts a single named argument object args <code>Array.&lt;string&gt;</code> Array of key names of the function's named argument object"},{"location":"helper-functions/#kudojscompose","title":"<code>kudoJS.compose</code>","text":"<p>Performs right-to-left function composition.</p> <p><code>compose(...fns: Function): Function</code></p> Param Type Description ...fns <code>function</code> Functions to compose"},{"location":"helper-functions/#kudojsconstant","title":"<code>kudoJS.constant</code>","text":"<p>Takes any value and returns a function that will return the same value, no matter what you pass to it.</p> <p><code>constant(x: any): any</code></p> Param Type Description x <code>*</code> Any"},{"location":"helper-functions/#kudojsfmap","title":"<code>kudoJS.fmap</code>","text":"<p>Takes a function and a functor, applies the function to each of the functor's values, and returns a functor.</p> <p><code>fmap(fn: (a: A) =&gt; B, f: Functor&lt;A&gt;): Functor&lt;B&gt;</code></p> Param Type Description fn <code>function</code> Function to be mapped f <code>Functor</code> Functor"},{"location":"helper-functions/#kudojsassoc","title":"<code>kudoJS.assoc</code>","text":"<p>Associates a value with the specified key in the object and returns a clone of the original object.</p> <p><code>assoc(key: string, value: A, o: {[k:string]: A}): {[k:string]: A}</code></p> Param Type Description key <code>string</code> Key value <code>any</code> Value to be assigned to the key in the object o <code>Object</code> Object to which the value needs to be assigned against the key"},{"location":"helper-functions/#kudojsbimap","title":"<code>kudoJS.bimap</code>","text":"<p>Maps both sides of the disjunction.</p> <p><code>bimap(f1: (a: A) =&gt; C, f2: (b: B) =&gt; D, b: BiFunctor&lt;A, B&gt;): BiFunctor&lt;C, D&gt;</code></p> Param Type Description f1 <code>function</code> Function to be applied on the left side of the disjunction f2 <code>function</code> Function to be applied on the right side of the disjunction b <code>BiFunctor</code> BiFunctor"},{"location":"helper-functions/#kudojschain","title":"<code>kudoJS.chain</code>","text":"<p>Chains together many computations of the same type.</p> <p><code>chain(f: (a: A) =&gt; Monad&lt;B&gt;, m: Monad&lt;A&gt;): Monad&lt;B&gt;</code></p> Param Type Description f <code>function</code> Function that returns a Monad m <code>Monad</code> Monad"},{"location":"helper-functions/#kudojscaseof","title":"<code>kudoJS.caseOf</code>","text":"<p>Conditional behavior based on the structure of algebraic data types.</p> <p><code>caseOf(o: Object, p: ADT): any</code></p> Param Type Description o <code>Object</code> An object with key as the ADT constructor name and value as the function expression p <code>PatternMatch</code> An ADT that supports pattern matching <p>Example:</p> <pre><code>import {caseOf, Maybe} from \"fp-kudojs\";\n\nconst j1 = Maybe.Just(1);\n\nconst k1 = caseOf({\n    Nothing: () =&gt; null,\n    Just: (v) =&gt; v+1\n}, j1);\n//k1 = 2;\n</code></pre>"},{"location":"helper-functions/#kudojsliftan","title":"<code>kudoJS.liftAn</code>","text":"<p>Combines <code>n</code> separate wrapped values into one with a given function.</p> <p><code>liftAn(f: (a: A ...an: A) =&gt; B, ar: Array&lt;Apply&lt;A&gt;&gt;): Apply&lt;B&gt;</code></p> Param Type Description f <code>function</code> Function with <code>n</code> arguments to be lifted ar <code>Apply</code> Array of wrapped values (<code>Apply&lt;A&gt;</code>). The values will be passed as arguments to the function <code>f</code>"},{"location":"helper-functions/#kudojslifta2","title":"<code>kudoJS.liftA2</code>","text":"<p>Combines 2 separate wrapped values into one with a given function.</p> <p><code>liftA2(f: (a1: A, a2: A) =&gt; B, ar1: Apply&lt;A&gt;, ar2: Apply&lt;A&gt;): Apply&lt;B&gt;</code></p> Param Type Description f <code>function</code> Function to be lifted ar1 <code>Apply</code> Wrapped value (Apply) ar2 <code>Apply</code> Wrapped value (Apply)"},{"location":"helper-functions/#kudojslifta3","title":"<code>kudoJS.liftA3</code>","text":"<p>Combines 3 separate wrapped values into one with a given function.</p> <p><code>liftA3(f: (a1: A, a2: A, a3: A) =&gt; B, ar1: Apply&lt;A&gt;, ar2: Apply&lt;A&gt;, ar3: Apply&lt;A&gt;): Apply&lt;B&gt;</code></p> Param Type Description f <code>function</code> Function to be lifted ar1 <code>Apply</code> Wrapped value (Apply) ar2 <code>Apply</code> Wrapped value (Apply) ar3 <code>Apply</code> Wrapped value (Apply)"},{"location":"helper-functions/#kudojslifta4","title":"<code>kudoJS.liftA4</code>","text":"<p>Combines 4 separate wrapped values into one with a given function.</p> <p><code>liftA4(f: (a1: A, a2: A, a3: A, a4: A) =&gt; B, ar1: Apply&lt;A&gt;, ar2: Apply&lt;A&gt;, ar3: Apply&lt;A&gt;, ar4: Apply&lt;A&gt;): Apply&lt;B&gt;</code></p> Param Type Description f <code>function</code> Function to be lifted ar1 <code>Apply</code> Wrapped value (Apply) ar2 <code>Apply</code> Wrapped value (Apply) ar3 <code>Apply</code> Wrapped value (Apply) ar4 <code>Apply</code> Wrapped value (Apply)"},{"location":"helper-functions/#kudojslifta5","title":"<code>kudoJS.liftA5</code>","text":"<p>Combines 5 separate wrapped values into one with a given function.</p> <p><code>liftA5(f: (a1: A, a2: A, a3: A, a4: A, a5: A) =&gt; B, ar1: Apply&lt;A&gt;, ar2: Apply&lt;A&gt;, ar3: Apply&lt;A&gt;, ar4: Apply&lt;A&gt;, ar5: Apply&lt;A&gt;): Apply&lt;B&gt;</code></p> Param Type Description f <code>function</code> Function to be lifted ar1 <code>Apply</code> Wrapped value (Apply) ar2 <code>Apply</code> Wrapped value (Apply) ar3 <code>Apply</code> Wrapped value (Apply) ar4 <code>Apply</code> Wrapped value (Apply) ar5 <code>Apply</code> Wrapped value (Apply)"},{"location":"helper-functions/#kudojswhen","title":"<code>kudoJS.when</code>","text":"<p>Returns a function that takes one argument and passes it to the given predicate function. If the predicate is satisfied, <code>f</code> is run with the same argument. If the predicate is not satisfied, the argument is returned as is.</p> <p><code>when(p: Function, f: Function): Function</code></p> Param Type Description p <code>function</code> Predicate function that returns <code>true</code> or <code>false</code> based on the argument passed f <code>function</code> Function to be executed with the given argument when the predicate is satisfied"},{"location":"helper-functions/#kudojsprop","title":"<code>kudoJS.prop</code>","text":"<p>Returns a Maybe Just if a value exists for the given key; otherwise, returns a Nothing.</p> <p><code>prop(key: string | number, o: { [k: string]: A; [k: number]: A }): Maybe&lt;A&gt;</code></p> <p>| Param | Type                | Description      | | ----- | ------------------- | ---------------- | --- | | key   | <code>string        | number</code>    | Key | | o     | <code>Object</code> | Key-Value Object |</p>"},{"location":"helper-functions/#kudojspick","title":"<code>kudoJS.pick</code>","text":"<p>Returns a Maybe Just containing the object with only the specified keys if values exist for the given keys; otherwise, returns a Nothing.</p> <p><code>pick(keys: Array&lt;string&gt;, o: { [k: string]: A }): Maybe&lt;{[k: string]: A}&gt;</code></p> Param Type Description keys <code>Array Keys o <code>Object</code> Key-Value Object"},{"location":"helper-functions/#kudojseithertomaybe","title":"<code>kudoJS.eitherToMaybe</code>","text":"<p>Converts an Either type to a Maybe type.</p> <p><code>eitherToMaybe(e: Either&lt;A, B&gt;): Maybe&lt;A&gt;</code></p> Param Type Description e <code>Either</code> Either type"},{"location":"helper-functions/#kudojsmaybetoeither","title":"<code>kudoJS.maybeToEither</code>","text":"<p>Converts a Maybe type to an Either type.</p> <p><code>maybeToEither(m: Maybe&lt;A&gt;): Either&lt;A&gt;</code></p> Param Type Description m <code>Maybe</code> Maybe type <p>TODO: Add more documentation and examples</p>"},{"location":"identity/","title":"Identity","text":""},{"location":"identity/#identity","title":"Identity","text":"<p>An Identity is a wrapper for a value that cannot be changed. It is useful for handling pure values.</p> <p>Implements: Monad, Semigroup, Setoid</p> <ul> <li>Identity<ul> <li>Identity(v)</li> <li>Identity.of(v)</li> <li>Identity.equals(j)</li> <li>Identity.concat(p)</li> <li>Identity.getValue()</li> <li>Identity.map(f)</li> <li>Identity.chain(f)</li> <li>Identity.toString()</li> <li>Examples</li> </ul> </li> </ul> <p></p>"},{"location":"identity/#identityv","title":"Identity(v)","text":"<p>The Identity constructor.</p> Param Type Description v <code>any</code> The value to be wrapped by Identity. This cannot be <code>undefined</code>. <p></p>"},{"location":"identity/#identityofv","title":"Identity.of(v)","text":"<p>Identity constructor.</p> Param Type Description v <code>any</code> The value to be wrapped by Identity. This cannot be <code>undefined</code>. <p></p>"},{"location":"identity/#identityequalsj","title":"Identity.equals(j)","text":"<p>Checks if the value of the current Identity is equal to the value of the passed Identity. This uses strict equality (<code>===</code>) to compare the values of the two Identities.</p> Param Type Description j <code>Identity</code> The Identity to compare with <p></p>"},{"location":"identity/#identityconcatp","title":"Identity.concat(p)","text":"<p>Concatenates the current Identity with the passed one. Note that the values of both Identities must be of the same type and must be of a type that supports the <code>Semigroup</code> concatenation operation for this to work.</p> Param Type Description p <code>Identity</code> The Identity to concatenate with <p></p>"},{"location":"identity/#identitygetvalue","title":"Identity.getValue()","text":"<p>Gets the value within the Identity.</p> <p></p>"},{"location":"identity/#identitymapf","title":"Identity.map(f)","text":"<p>Applies the function to the value of the current Identity.</p> Param Type Description f <code>function</code> Function <p></p>"},{"location":"identity/#identitychainf","title":"Identity.chain(f)","text":"<p>Chains a computation that returns an Identity.</p> Param Type Description f <code>function</code> Function that returns another Identity <p></p>"},{"location":"identity/#identitytostring","title":"Identity.toString()","text":"<p>Returns a stringified version of the Identity.</p>"},{"location":"identity/#examples","title":"Examples","text":"<p>TODO: Add some examples</p>"},{"location":"maybe/","title":"Maybe","text":""},{"location":"maybe/#maybe","title":"Maybe","text":"<p><code>Maybe</code> is a structure for values that may not be present or for situations that may fail. A <code>Maybe</code> can help in dealing with optional values, arguments, records with optional fields, etc.</p> <p>Implements: <code>Alt</code>, <code>Monad</code>, <code>Semigroup</code>, <code>Setoid</code></p> <ul> <li>Maybe<ul> <li>Maybe.of(v)</li> <li>Maybe.zero()</li> <li>Maybe.Just(v)</li> <li>Maybe.Nothing()</li> <li>Maybe.fromNullable(v)</li> <li>Maybe.withDefault(def, v)</li> <li>Maybe.catMaybes(ar)</li> <li>Maybe.isNothing(v)</li> <li>Maybe.isJust(v)</li> <li>Maybe.equals(n)</li> <li>Maybe.map(f)</li> <li>Maybe.chain(f)</li> <li>Maybe.isNothing()</li> <li>Maybe.isJust()</li> <li>Maybe.alt(v)</li> <li>Maybe.ap(j)</li> <li>Maybe.getValue()</li> </ul> </li> </ul> <p></p>"},{"location":"maybe/#maybeofv","title":"Maybe.of(v)","text":"<p>Creates a <code>Just v</code>.</p> Param Type Description v <code>any</code> Value <p></p>"},{"location":"maybe/#maybezero","title":"Maybe.zero()","text":"<p>Creates a <code>Nothing</code>.</p> <p></p>"},{"location":"maybe/#maybejustv","title":"Maybe.Just(v)","text":"<p>Creates a <code>Just v</code>.</p> Param Type Description v <code>any</code> Value <p></p>"},{"location":"maybe/#maybenothing","title":"Maybe.Nothing()","text":"<p>Creates a <code>Nothing</code>.</p> <p></p>"},{"location":"maybe/#maybefromnullablev","title":"Maybe.fromNullable(v)","text":"<p>Creates a <code>Just</code> if the value is not <code>null</code> or <code>undefined</code>; otherwise, creates a <code>Nothing</code>.</p> Param Type Description v <code>any</code> Value <p></p>"},{"location":"maybe/#maybewithdefaultdef-v","title":"Maybe.withDefault(def, v)","text":"<p>Creates a <code>Just</code> if the value <code>v</code> is not <code>null</code> or <code>undefined</code>; otherwise, creates a <code>Just</code> with the default value <code>def</code>.</p> Param Type Description def <code>any</code> Default value v <code>any</code> Value <p></p>"},{"location":"maybe/#maybecatmaybesar","title":"Maybe.catMaybes(ar)","text":"<p>A static method that takes an array of <code>Maybe</code> values and returns an array of the values of all the <code>Just</code> elements in the passed array.</p> Param Type Description ar <code>Array.&lt;any&gt;</code> Array of <code>Maybe</code> values <p></p>"},{"location":"maybe/#maybeisnothingv","title":"Maybe.isNothing(v)","text":"<p>A static method that returns <code>true</code> if the passed <code>Maybe</code> is a <code>Nothing</code>.</p> Param Type Description v <code>any</code> <code>Maybe</code> <p></p>"},{"location":"maybe/#maybeisjustv","title":"Maybe.isJust(v)","text":"<p>A static method that returns <code>true</code> if the passed <code>Maybe</code> is a <code>Just</code>.</p> Param Type Description v <code>any</code> <code>Maybe</code> <p></p>"},{"location":"maybe/#maybeequalsn","title":"Maybe.equals(n)","text":"<p>Returns <code>true</code> if the current and the passed elements are of the <code>Maybe</code> type with the same value.</p> Param Type Description n <code>any</code> Any value of type <code>Setoid</code> <p></p>"},{"location":"maybe/#maybemapf","title":"Maybe.map(f)","text":"<p>Applies the passed function to the value of the current <code>Maybe</code> if it is a <code>Just</code>.</p> Param Type Description f <code>function</code> Function <p></p>"},{"location":"maybe/#maybechainf","title":"Maybe.chain(f)","text":"<p>Chains together many computations that return a <code>Maybe</code> type.</p> Param Type Description f <code>function</code> Function that returns another <code>Maybe</code> <p></p>"},{"location":"maybe/#maybeisnothing","title":"Maybe.isNothing()","text":"<p>Returns <code>true</code> if the current <code>Maybe</code> is a <code>Nothing</code>.</p> <p></p>"},{"location":"maybe/#maybeisjust","title":"Maybe.isJust()","text":"<p>Returns <code>true</code> if the current <code>Maybe</code> is a <code>Just</code>.</p> <p></p>"},{"location":"maybe/#maybealtv","title":"Maybe.alt(v)","text":"<p>An instance method that returns the current <code>Maybe</code> if it is a <code>Just</code>; otherwise, returns the passed <code>Maybe</code>.</p> Param Type Description v <code>any</code> <code>Maybe</code> <p></p>"},{"location":"maybe/#maybeapj","title":"Maybe.ap(j)","text":"<p>Applies the function inside the passed <code>Maybe</code> to the current <code>Maybe</code> if it is a <code>Just</code>.</p> Param Type Description j <code>any</code> <code>Maybe</code> with a function <p></p>"},{"location":"maybe/#maybegetvalue","title":"Maybe.getValue()","text":"<p>Gets the value within the <code>Maybe</code>.</p>"},{"location":"pair/","title":"Pair","text":""},{"location":"pair/#pair","title":"Pair","text":"<p>A <code>Pair</code> is a structure for storing two values in a single value. The elements of a <code>Pair</code> do not need to be of the same type.</p> <p>Implements: <code>BiFunctor</code>, <code>Monad</code>, <code>Semigroup</code>, <code>Setoid</code></p> <ul> <li>Pair<ul> <li>Pair(v1, v2)</li> <li>Pair.of(v)</li> <li>Pair.equals(j)</li> <li>Pair.concat(p)</li> <li>Pair.fst()</li> <li>Pair.snd()</li> <li>Pair.concat(j)</li> <li>Pair.getValue()</li> <li>Pair.map(f)</li> <li>Pair.bimap(f1, f2)</li> <li>Pair.chain(f)</li> <li>Pair.swap()</li> <li>Pair.toString()</li> <li>Examples</li> </ul> </li> </ul> <p></p>"},{"location":"pair/#pairv1-v2","title":"Pair(v1, v2)","text":"<p>Pair constructor.</p> Param Type Description v1 <code>any</code> First element of the Pair v2 <code>any</code> Second element of the Pair <p></p>"},{"location":"pair/#pairofv","title":"Pair.of(v)","text":"<p>Pair constructor.</p> Param Type Description v <code>any</code> Element that will be stored as both the first and second element of the Pair <p></p>"},{"location":"pair/#pairequalsj","title":"Pair.equals(j)","text":"<p>Checks if the values of the current <code>Pair</code> are equal to the values of the passed <code>Pair</code>. Pairs are equal only if the first and second values of both pairs are equal.</p> Param Type Description j <code>Pair</code> The <code>Pair</code> to compare with <p></p>"},{"location":"pair/#pairconcatp","title":"Pair.concat(p)","text":"<p>Concatenates the current <code>Pair</code> with the passed one. Note that both the first and second elements of the <code>Pair</code> must be of type <code>Semigroup</code> for concatenation to work.</p> Param Type Description p <code>Pair</code> <code>Pair</code> to concat <p></p>"},{"location":"pair/#pairfst","title":"Pair.fst()","text":"<p>Gets the first element of the <code>Pair</code>.</p> <p></p>"},{"location":"pair/#pairsnd","title":"Pair.snd()","text":"<p>Gets the second element of the <code>Pair</code>.</p> <p></p>"},{"location":"pair/#pairconcatj","title":"Pair.concat(j)","text":"<p>Applies the function inside the second element of the passed <code>Pair</code> to the current <code>Pair</code> and concatenates the first element of the second <code>Pair</code> to the first element of the current <code>Pair</code>.</p> Param Type Description j <code>Pair</code> <code>Pair</code> with a function as the second element <p></p>"},{"location":"pair/#pairgetvalue","title":"Pair.getValue()","text":"<p>Gets the values within the <code>Pair</code> as an array of length 2.</p> <p></p>"},{"location":"pair/#pairmapf","title":"Pair.map(f)","text":"<p>Applies the passed function to the second element of the current <code>Pair</code>.</p> Param Type Description f <code>function</code> Function <p></p>"},{"location":"pair/#pairbimapf1-f2","title":"Pair.bimap(f1, f2)","text":"<p>Applies <code>f1</code> to the first element and <code>f2</code> to the second element of the current <code>Pair</code>.</p> Param Type Description f1 <code>function</code> Function to be applied to the first element f2 <code>function</code> Function to be applied to the second element <p></p>"},{"location":"pair/#pairchainf","title":"Pair.chain(f)","text":"<p>Chains together many computations that return a <code>Pair</code>.</p> Param Type Description f <code>function</code> Function that returns another <code>Pair</code> <p></p>"},{"location":"pair/#pairswap","title":"Pair.swap()","text":"<p>Swaps the elements of the current <code>Pair</code>.</p> <p></p>"},{"location":"pair/#pairtostring","title":"Pair.toString()","text":"<p>Gets a stringified version of the <code>Pair</code>.</p>"},{"location":"pair/#examples","title":"Examples","text":"<p>Let's construct some <code>Pairs</code>.</p> <pre><code>import { Pair } from \"fp-kudojs\";\n\nconst point1 = Pair(1, 2);\nconsole.log(point1.toString()); // Pair((1), (2))\n\nconst point2 = Pair.of(2);\nconsole.log(point2.toString()); // Pair((2), (2))\n\n\n### Examples\n\nLets construct some Pairs\n\n</code></pre> <p>import {Pair} from \"fp-kudojs\";</p> <p>const point1 = Pair(1, 2); console.log(point1.toString()); // Pair((1), (2))</p> <p>const point2 = Pair.of(2); console.log(point2.toString()); // Pair((2), (2))</p> <pre><code>\nTwo Pairs are equal if the first and the second element of each Pair are equal\n\n</code></pre> <p>console.log(point1.equals(Pair(1,2))) //true</p> <p>console.log(point2.equals(point1) //false</p> <p>console.log(Pair([1], [2]).equals(Pair([1],[2]))) //false</p> <pre><code>\nConcatenate Pairs. Note that to concatenate Pairs, the elements of each Pair should be Semigroups of the same type.\n\n</code></pre> <p>const p1 = Pair([1], [2]); const p2 = Pair([3], [4]);</p> <p>const p3 = p1.concat(p2);</p> <p>console.log(p3.getValue()); // [[1, 3], [2, 4]]</p> <pre><code>\n** TODO: Add more examples **\n</code></pre>"},{"location":"reader/","title":"Reader","text":""},{"location":"reader/#reader","title":"Reader","text":"<p>The <code>Reader</code> monad represents a computation that can read values from a shared environment, pass values from function to function, and execute sub-computations in a modified environment. It is also useful for dependency injection.</p> <p>Implements: <code>Monad</code></p> <ul> <li>Reader<ul> <li>Reader(f)</li> <li>Reader.of(v)</li> <li>Reader.toString()</li> <li>Reader.map(f)</li> <li>Reader.getValue()</li> <li>Reader.ap(t)</li> <li>Reader.chain(f)</li> <li>Reader.runWith(e)</li> </ul> </li> </ul> <p></p>"},{"location":"reader/#readerf","title":"Reader(f)","text":"<p>The <code>Reader</code> constructor.</p> Param Type Description f <code>function</code> A function of the form <code>(e -&gt; a)</code> that is wrapped by the <code>Reader</code>. Nothing is executed until it is run with an environment. <p></p>"},{"location":"reader/#readerofv","title":"Reader.of(v)","text":"<p>The <code>Reader</code> constructor that populates the right portion with its argument. <code>of</code> essentially lifts a value of type <code>a</code> into a <code>Reader</code>.</p> Param Type Description v <code>any</code> Any value that needs to be lifted into the <code>Reader</code> <p></p>"},{"location":"reader/#readertostring","title":"Reader.toString()","text":"<p>Gets a stringified version of the <code>Reader</code>.</p> <p></p>"},{"location":"reader/#readermapf","title":"Reader.map(f)","text":"<p>Applies the function <code>f</code> to the right portion of the <code>Reader</code>.</p> Param Type Description f <code>function</code> Function <p></p>"},{"location":"reader/#readergetvalue","title":"Reader.getValue()","text":"<p>Gets the function within the <code>Reader</code>.</p> <p></p>"},{"location":"reader/#readerapt","title":"Reader.ap(t)","text":"<p><code>ap</code> allows for values wrapped in a <code>Reader</code> to be applied to functions also wrapped in a <code>Reader</code>. In order to use <code>ap</code>, the <code>Reader</code> must contain a function as its value.</p> Param Type Description t <code>Reader</code> A <code>Reader</code> with a function as its value <p></p>"},{"location":"reader/#readerchainf","title":"Reader.chain(f)","text":"<p>Chains together many computations that return a <code>Reader</code>.</p> Param Type Description f <code>function</code> Function that returns another <code>Reader</code> <p></p>"},{"location":"reader/#readerrunwithe","title":"Reader.runWith(e)","text":"<p>Since <code>Reader</code> is a lazy datatype that requires a shared environment to run, its instance provides a <code>runWith</code> method. This method takes in an environment and returns the result of the computation.</p> Param Type Description e <code>any</code> An environment that needs to be passed to the <code>Reader</code>"},{"location":"setup/","title":"Setup","text":""},{"location":"setup/#installation","title":"Installation","text":"<p>Install and save KudoJS as a dependency in your current project</p> <pre><code>$ npm install --save fp-kudojs\n</code></pre>"},{"location":"setup/#import-using-commonjs","title":"Import using CommonJS","text":"<pre><code>const kudoJS = require(\"fp-kudojs\")\n</code></pre>"},{"location":"setup/#import-using-es-modules","title":"Import using ES Modules","text":"<pre><code>import kudoJS from \"fp-kudojs\"\n</code></pre>"},{"location":"setup/#import-single-entities-using-commonjs","title":"Import single entities using CommonJS","text":"<pre><code>const compose = require(\"fp-kudojs/function/compose\");\nconst Maybe = require(\"fp-kudojs/adt/Maybe\");\n</code></pre>"},{"location":"setup/#import-single-entities-using-es-modules","title":"Import single entities using ES Modules","text":"<pre><code>import compose from \"fp-kudojs/function/compose\";\nimport Maybe from \"fp-kudojs/adt/Maybe\";\n</code></pre>"},{"location":"state/","title":"State","text":""},{"location":"state/#state","title":"State","text":"<p><code>State</code> is parameterized by two types: a state <code>&lt;code&gt;s&lt;/code&gt;</code> and a result <code>&lt;code&gt;a&lt;/code&gt;</code>. <code>State</code> should wrap a function of the form <code>&lt;code&gt;s -&gt; Pair a s&lt;/code&gt;</code> and can be constructed by providing a function of this form. There are three methods available on the <code>State</code> for running with a given initial state.</p> <p>Implements: <code>Monad</code></p> <ul> <li>State<ul> <li>State(f)</li> <li>State.of(v)</li> <li>State.toString()</li> <li>State.map(f)</li> <li>State.getValue()</li> <li>State.ap(t)</li> <li>State.chain(f)</li> <li>State.runWith(s)</li> <li>State.execWith(s)</li> <li>State.evalWith(s)</li> </ul> </li> </ul> <p></p>"},{"location":"state/#statef","title":"State(f)","text":"<p>The <code>State</code> constructor.</p> Param Type Description f <code>function</code> A function of the form <code>s -&gt; Pair a</code> that is wrapped by the <code>State</code>. Nothing is executed until it is run with an initial state <code>s</code>. <p></p>"},{"location":"state/#stateofv","title":"State.of(v)","text":"<p>The <code>State</code> constructor that populates the right portion with its argument. <code>of</code> essentially lifts a value of type <code>a</code> into a <code>State</code>.</p> Param Type Description v <code>any</code> Any value that needs to be lifted into the <code>State</code> <p></p>"},{"location":"state/#statetostring","title":"State.toString()","text":"<p>Gets a stringified version of the <code>State</code>.</p> <p></p>"},{"location":"state/#statemapf","title":"State.map(f)","text":"<p>Applies the function <code>f</code> to the right portion of the <code>State</code>.</p> Param Type Description f <code>function</code> Function <p></p>"},{"location":"state/#stategetvalue","title":"State.getValue()","text":"<p>Gets the function within the <code>State</code>.</p> <p></p>"},{"location":"state/#stateapt","title":"State.ap(t)","text":"<p><code>ap</code> allows for values wrapped in a <code>State</code> to be applied to functions also wrapped in a <code>State</code>. In order to use <code>ap</code>, the <code>State</code> must contain a function as its value on the right side.</p> Param Type Description t <code>State</code> A <code>State</code> with a function as its right element <p></p>"},{"location":"state/#statechainf","title":"State.chain(f)","text":"<p>Chains together many computations that return a <code>State</code>.</p> Param Type Description f <code>function</code> Function that returns another <code>State</code> <p></p>"},{"location":"state/#staterunwiths","title":"State.runWith(s)","text":"<p>Since <code>State</code> is a lazy datatype that requires an initial state to run, it provides a <code>runWith</code> method that takes in an initial state and returns the result of the computation as a <code>&lt;code&gt;Pair result state&lt;/code&gt;</code>.</p> Param Type Description s <code>any</code> An initial state that needs to be passed to the <code>State</code> <p></p>"},{"location":"state/#stateexecwiths","title":"State.execWith(s)","text":"<p>When called, <code>execWith</code> will run the state transition with the given value as the initial state and return the state.</p> Param Type Description s <code>any</code> An initial state that needs to be passed to the <code>State</code> <p></p>"},{"location":"state/#stateevalwiths","title":"State.evalWith(s)","text":"<p>When called, <code>evalWith</code> will run the state transition with the given value as the initial state and return the result.</p> Param Type Description s <code>any</code> An initial state that needs to be passed to the <code>State</code>"},{"location":"task/","title":"Task","text":""},{"location":"task/#task","title":"Task","text":"<p>A <code>Task</code> makes it easy to model asynchronous operations that may fail, such as HTTP requests or reading/writing to files/databases.</p> <p>Implements: <code>Monad</code>, <code>Semigroup</code></p> <ul> <li>Task<ul> <li>Task(f)</li> <li>Task.of(v)</li> <li>Task.rejected(v)</li> <li>Task.fork(reject, resolve)</li> <li>Task.toString()</li> <li>Task.map(f)</li> <li>Task.getValue()</li> <li>Task.ap(t)</li> <li>Task.concat(t)</li> <li>Task.chain(f)</li> <li>Task.toPromise()</li> </ul> </li> </ul> <p></p>"},{"location":"task/#taskf","title":"Task(f)","text":"<p><code>Task</code> constructor.</p> Param Type Description f <code>function</code> A function that takes two arguments: <code>reject</code> and <code>resolve</code>, which are functions. The function <code>f</code> normally initiates an asynchronous task or one that has side effects, and once it completes, it either calls the <code>resolve</code> function to resolve the task or rejects it. <p></p>"},{"location":"task/#taskofv","title":"Task.of(v)","text":"<p><code>Task</code> constructor that creates a <code>Task</code> which immediately resolves.</p> Param Type Description v <code>any</code> The value that is passed to the <code>resolve</code> function <p></p>"},{"location":"task/#taskrejectedv","title":"Task.rejected(v)","text":"<p><code>Task</code> constructor that creates a <code>Task</code> which immediately gets rejected.</p> Param Type Description v <code>any</code> The value that is passed to the <code>rejected</code> function <p></p>"},{"location":"task/#taskforkreject-resolve","title":"Task.fork(reject, resolve)","text":"<p>Executes the <code>Task</code>.</p> Param Type Description reject <code>function</code> Function to be called when the <code>Task</code> is rejected resolve <code>function</code> Function to be called when the <code>Task</code> is resolved <p></p>"},{"location":"task/#tasktostring","title":"Task.toString()","text":"<p>Gets a stringified version of the <code>Task</code>.</p> <p></p>"},{"location":"task/#taskmapf","title":"Task.map(f)","text":"<p>Applies the function <code>f</code> to the value of a successfully resolved <code>Task</code>.</p> Param Type Description f <code>function</code> Function <p></p>"},{"location":"task/#taskgetvalue","title":"Task.getValue()","text":"<p>Gets the function within the <code>Task</code>.</p> <p></p>"},{"location":"task/#taskapt","title":"Task.ap(t)","text":"<p>Applies the successful value of the <code>Task</code> <code>t</code> to the successful value (a function) of the current <code>Task</code>.</p> Param Type Description t <code>Task</code> <code>Task</code> with a function as the second element <p></p>"},{"location":"task/#taskconcatt","title":"Task.concat(t)","text":"<p>Concatenates the current <code>Task</code> with the passed one and returns a new <code>Task</code>. When resolved, it will return the successful result of both tasks.</p> Param Type Description t <code>Task</code> <code>Task</code> to concatenate <p></p>"},{"location":"task/#taskchainf","title":"Task.chain(f)","text":"<p>Chains together many computations that return a <code>Task</code>.</p> Param Type Description f <code>function</code> Function that returns another <code>Task</code> <p></p>"},{"location":"task/#tasktopromise","title":"Task.toPromise()","text":"<p>Converts the current <code>Task</code> to a <code>Promise</code>.</p>"}]}