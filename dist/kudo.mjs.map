{"version":3,"file":"kudo.mjs","sources":["../src/functions/helpers.ts","../src/data-types/maybe.ts","../src/index.ts"],"sourcesContent":["import Functor from \"../implements/functor\";\nimport PatternMatch from \"../implements/patternmatch\";\n\nconst slice = Array.prototype.slice;\n\n//throwError :: String -> Error\nconst throwError = (x: String): Error => {\n    throw x;\n};\n\n//id :: a -> a\nconst id = (x: any): any => x;\n\n//fmap :: Functor f  => (a -> b) -> f a -> f b\nconst fmap = (fn: Function, f: Functor): Functor | Error =>\n    typeof fn !== \"function\"\n        ? throwError(\"function not provided\")\n        : !f.map ? throwError(\"map not implemented\") : f.map.call(null, fn);\n\n//caseOf :: Object -> patternMatch -> a\nconst caseOf = (o: Object, p: PatternMatch): any =>\n    !p.caseOf ? throwError(\"caseOf not implemented\") : p.caseOf.call(null, o);\n\n//curry :: Function -> Function\nconst curry = (fn: Function): Function | Error => {\n    if (typeof fn !== \"function\") return throwError(\"Function not provided\");\n\n    const arity = fn.length;\n    return function curried() {\n        let args = slice.call(arguments, 0);\n        if (args.length >= arity) return fn.apply(null, args);\n\n        return function() {\n            return curried.apply(null, args.concat(slice.call(arguments)));\n        };\n    };\n};\n\n//ncurry :: Function -> Function\nconst ncurry = (fn: Function): Function | Error => {\n    if (typeof fn !== \"function\") return throwError(\"Function not provided\");\n    if (fn.arguments.length > 1) return throwError(\"Function Arity cannot be greater than 1\");\n    if (typeof fn.arguments[0] !== \"object\") return throwError(\"Function argument must be an object type\");\n    const args = Object.keys(fn.arguments[0]);\n\n    return function curried(ar: Object): Function {\n        const curArgs = Object.keys(ar);\n        const diff = args.filter(x => curArgs.indexOf(x) < 0);\n        if(diff.length > 0) return (ar2: Object): Function => curried.call(null, (<any>Object).assign({}, ar, ar2));\n        return fn.call(null, ar);\n    };\n};\n\n//compose :: Array<Function> -> Function\nconst compose = (...fns: Array<Function>) => fns.reduce((f,g) => (...args:Array<any>) => f(g(...args)));\n\nexport {\n    id,\n    throwError,\n    fmap,\n    caseOf,\n    curry,\n    ncurry,\n    compose\n}","import Functor from \"../implements/functor\";\nimport PatternMatch from \"../implements/patternmatch\";\nimport {throwError} from \"../functions/helpers\";\n\nclass Nothing implements Functor, PatternMatch {\n    constructor() {\n        \n    }\n\n    getValue(){\n        return null;\n    }\n\n    map(f: Function){\n        return this;\n    }\n\n    isJust(){\n        return false;\n    }\n\n    isNothing(){\n        return true;\n    }\n\n    caseOf(o: {Nothing: Function}){\n        return o.Nothing ? o.Nothing() : throwError(\"Expected Nothing!\");\n    }\n}\n\nclass Just implements Functor, PatternMatch {\n    \n    value: any;\n\n    constructor(v: any){\n        this.value = v;\n    }\n\n    getValue(){\n        return this.value;\n    }\n\n    map(f: Function){\n        return new Just(f(this.value));\n    }\n\n    isJust(){\n        return true;\n    }\n\n    isNothing(){\n        return false;\n    }\n\n    caseOf(o: {Just: Function}){\n        return o.Just ? o.Just(this.value) : throwError(\"Expected Just\");\n    }\n}\n\nconst Maybe = {\n    Just: (v: any) => new Just(v),\n    Nothing: (v: any) => new Nothing(),\n    fromNullable: (v: any) => v ? new Just(v) : new Nothing(),\n    withDefault: (def: any, v: any) => v ? new Just(v) : new Just(def),\n    andThen: (cb: Function, m: Just | Nothing) => m instanceof Just ? cb.call(null, m.getValue()) : m instanceof Nothing ? m : throwError(\"Unexpected Type\"),\n    catMaybes: (ar: Array<Just|Nothing>) => ar.filter( m => m instanceof Just).map(m => m.getValue())\n}\n\nexport default Maybe;","import {\n    fmap,\n    caseOf,\n    curry,\n    ncurry,\n    compose\n} from \"./functions/helpers\"\n\nimport Maybe from \"./data-types/maybe\"\n\n//Algebraic Data Types\n\nconst Kudo = {\n    fmap,\n    caseOf,\n    curry,\n    ncurry,\n    compose,\n    Maybe\n};\n\nexport default Kudo;\n"],"names":["slice","Array","prototype","throwError","x","fmap","fn","f","map","call","caseOf","o","p","curry","arity","length","args","arguments","apply","curried","concat","ncurry","babelHelpers.typeof","Object","keys","ar","curArgs","diff","filter","indexOf","ar2","assign","compose","_i","fns","reduce","g","Nothing","v","value","Just","Maybe","def","cb","m","getValue","Kudo"],"mappings":"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"}