{"version":3,"file":"kudo.mjs","sources":["../src/functions/helpers.ts","../src/data-types/maybe.ts","../src/index.ts"],"sourcesContent":["import Functor from \"../implements/functor\";\nimport PatternMatch from \"../implements/patternmatch\";\nimport Monad from \"../implements/monad\";\nimport { Applicative } from \"../interfaces\";\n\nconst slice = Array.prototype.slice;\n\n//throwError :: String -> Error\nconst throwError = (x: String): Error => {\n    throw x;\n};\n\n//id :: a -> a\nconst id = (x: any): any => x;\n\n//curry :: Function -> Function\nconst curry = (fn: Function): Function | Error => {\n    if (typeof fn !== \"function\") return throwError(\"Function not provided\");\n\n    const arity = fn.length;\n    return function curried() {\n        let args = slice.call(arguments, 0);\n        if (args.length >= arity) return fn.apply(null, args);\n\n        return function() {\n            return curried.apply(null, args.concat(slice.call(arguments)));\n        };\n    };\n};\n\n//ncurry :: Function -> Function\nconst ncurry = (fn: Function, args: Array<string>): Function | Error => {\n    if (typeof fn !== \"function\") return throwError(\"Function not provided\");\n    if (fn.length > 1)\n        return throwError(\"Function Arity cannot be greater than 1\");\n    //if (typeof fn.arguments[0] !== \"object\") return throwError(\"Function argument must be an object type\");\n    //const args = Object.keys(fn.arguments[0]);\n\n    return function curried(ar: Object): Function {\n        const curArgs = Object.keys(ar);\n        const diff = args.filter(x => curArgs.indexOf(x) < 0);\n        if (diff.length > 0)\n            return (ar2: Object): Function =>\n                curried.call(null, (<any>Object).assign({}, ar, ar2));\n        return fn.call(null, ar);\n    };\n};\n\n//compose :: Array<Function> -> Function\nconst compose = (...fns: Array<Function>): Function | Error =>\n    fns.length > 0\n        ? fns.reduce((f, g) => (...args: Array<any>) => f(g(...args)))\n        : throwError(\"Nothing to compose!\");\n\n//fmap :: Functor f  => (a -> b) -> f a -> f b\nconst _fmap = (fn: Function, f: Functor): Functor | Error =>\n    typeof fn !== \"function\"\n        ? throwError(\"function not provided\")\n        : !f.map ? throwError(\"map not implemented\") : f.map.call(f, fn);\nconst fmap = curry(_fmap);\n\n//chain :: Monad m => m a -> (a -> m b) -> m b\nconst _chain = (m: Monad, f: Function): Monad | Error =>\n    !m.chain\n        ? throwError(\"chain not implemented\")\n        : typeof f !== \"function\"\n          ? throwError(\"function not provided\")\n          : m.chain.call(m, f);\nconst chain = curry(_chain);\n\n//caseOf :: Object -> patternMatch -> a\nconst _caseOf = (o: Object, p: PatternMatch): any =>\n    !p.caseOf ? throwError(\"caseOf not implemented\") : p.caseOf.call(null, o);\nconst caseOf = curry(_caseOf);\n\nexport { id, throwError, fmap, caseOf, curry, ncurry, compose };\n","// import Functor from \"../implements/functor\";\n// import Monad from \"../implements/monad\";\n// import PatternMatch from \"../implements/patternmatch\";\nimport {Setoid, Apply, Applicative, Functor, Monad, PatternMatch} from \"../interfaces\";\nimport {throwError} from \"../functions/helpers\";\n\nclass Nothing implements Monad, PatternMatch {\n\n    equals(n: Nothing){\n       return n instanceof Nothing\n    }\n\n    of(v: any){\n        return new Nothing();\n    }\n\n    ap(n: Nothing){\n        return this.of(n);\n    }\n\n    getValue(){\n        return null;\n    }\n\n    map(f: Function){\n        return this;\n    }\n\n    chain(f: Function){\n        return this\n    }\n\n    isJust(){\n        return false;\n    }\n\n    isNothing(){\n        return true;\n    }\n\n    toString(){\n        return \"Nothing()\";\n    }\n\n    caseOf(o: {Nothing: Function}){\n        return o.Nothing ? o.Nothing() : throwError(\"Expected Nothing!\");\n    }\n}\n\nclass Just implements Monad, PatternMatch {\n    \n    value: any;\n\n    constructor(v: any){\n        this.value = v;\n    }\n\n    equals(j: Just){\n        return j instanceof Just && j.getValue() === this.value;\n    }\n\n    of(v: any){\n        return new Just(v);\n    }\n\n    ap(j: Just | Nothing): Just | Nothing{\n        return j.map(this.value);\n    }\n\n    getValue(){\n        return this.value;\n    }\n\n    map(f: Function){\n        return new Just(f(this.value));\n    }\n\n    chain(f: Function){\n        return f(this.value);\n    }\n\n    isJust(){\n        return true;\n    }\n\n    isNothing(){\n        return false;\n    }\n\n    toString(){\n        return `Just(${this.value})`;\n    }\n\n    caseOf(o: {Just: Function}){\n        return o.Just ? o.Just(this.value) : throwError(\"Expected Just\");\n    }\n}\n\nconst Maybe = {\n    of: (v: any) => new Just(v),\n    Just: (v: any): Just => new Just(v),\n    Nothing: (v: any): Nothing => new Nothing(),\n    fromNullable: (v: any): Just | Nothing => v ? new Just(v) : new Nothing(),\n    withDefault: (def: any, v: any): Just => v ? new Just(v) : new Just(def),\n    andThen: (cb: Function, m: Just | Nothing): Just | Nothing | Error => m instanceof Just ? cb.call(null, m.getValue()) : m instanceof Nothing ? m : throwError(\"Unexpected Type\"),\n    catMaybes: (ar: Array<Just|Nothing>): Array<any> => ar.filter( m => m instanceof Just).map(m => m.getValue())\n}\n\nexport default Maybe;","import {\n    fmap,\n    caseOf,\n    curry,\n    ncurry,\n    compose\n} from \"./functions/helpers\"\n\nimport Maybe from \"./data-types/maybe\"\n\n//Algebraic Data Types\n\nconst Kudo = {\n    fmap,\n    caseOf,\n    curry,\n    ncurry,\n    compose,\n    Maybe\n};\n\nexport default Kudo;\n"],"names":["slice","Array","prototype","throwError","x","curry","fn","arity","length","args","call","arguments","apply","curried","concat","ncurry","ar","curArgs","Object","keys","diff","filter","indexOf","ar2","assign","compose","_i","fns","reduce","f","g","_fmap","map","fmap","_chain","m","chain","_caseOf","o","p","caseOf","n","Nothing","v","of","value","j","Just","getValue","Maybe","def","cb","Kudo"],"mappings":"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"}