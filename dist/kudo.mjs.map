{"version":3,"file":"kudo.mjs","sources":["../src/functions/helpers.ts","../src/data-types/pair-type.ts","../src/data-types/pair.ts","../src/data-types/either.ts","../src/data-types/maybe.ts","../src/data-types/task-type.ts","../src/data-types/task.ts","../src/index.ts"],"sourcesContent":["import Functor from \"../implements/functor\";\nimport PatternMatch from \"../implements/patternmatch\";\nimport Monad from \"../implements/monad\";\nimport { Apply, BiFunctor } from \"../interfaces\";\n\nconst slice = Array.prototype.slice;\n\n//throwError :: String -> Error\nconst throwError = (x: String): Error => {\n    throw x;\n};\n\n//id :: a -> a\nconst id = (x: any): any => x;\n\n//isFunction :: Function -> boolean\nconst isFunction = (f: any) => typeof f === \"function\";\n\n//once :: Function -> Function\nconst once = (f: Function) => {\n    if(!isFunction(f)) throwError(\"Function not provided\");\n    let _called = false;\n    let _result: any = undefined;\n\n    return (...args: Array<any>) => {\n        if(!_called){\n            _called = true;\n            _result = f.apply(null, args);\n        }\n        return _result;\n    }\n}\n//curry :: Function -> Function\nconst curry = (fn: Function): Function => {\n    if (!isFunction(fn)) throwError(\"Function not provided\");\n\n    const arity = fn.length;\n    return function curried() {\n        let args = slice.call(arguments, 0);\n        if (args.length >= arity) return fn.apply(null, args);\n\n        return function() {\n            return curried.apply(null, args.concat(slice.call(arguments)));\n        };\n    };\n};\n\n//ncurry :: Function -> Function\nconst ncurry = (fn: Function, args: Array<string>): Function => {\n    if (!isFunction(fn)) throwError(\"Function not provided\");\n    if (fn.length > 1) throwError(\"Function Arity cannot be greater than 1\");\n    //if (typeof fn.arguments[0] !== \"object\") return throwError(\"Function argument must be an object type\");\n    //const args = Object.keys(fn.arguments[0]);\n\n    return function curried(ar: Object): Function {\n        const curArgs = Object.keys(ar);\n        const diff = args.filter(x => curArgs.indexOf(x) < 0);\n        if (diff.length > 0)\n            return (ar2: Object): Function =>\n                curried.call(null, (<any>Object).assign({}, ar, ar2));\n        return fn.call(null, ar);\n    };\n};\n\n//compose :: Array<Function> -> Function\nconst compose = (...fns: Array<Function>): Function => {\n    if(fns.length <= 0) throwError(\"Nothing to compose!\");\n    return fns.reduce((f, g) => (...args: Array<any>) => f(g(...args)));\n}\n    \n\n//fmap :: Functor f  => (a -> b) -> f a -> f b\nconst _fmap = (fn: Function, f: Functor): Functor => {\n    if(!isFunction(fn)) throwError(\"function not provided\");\n    if(!f.map) throwError(\"Functor not found\");\n    return f.map.call(f, fn);\n}\nconst fmap = curry(_fmap);\n\n//bimap :: BiFunctor b => b a c ~> (a -> e) -> (c -> d) ->  b a c -> b e d  \nconst _bimap = (f1: Function, f2: Function, b: BiFunctor): BiFunctor => {\n    if(!isFunction(f1) || !isFunction(f2)) throwError(\"Functions not provided\");\n    if(!b.bimap) throwError(\"BiFunctor not found\");\n    return b.bimap(f1, f2);\n}\nconst bimap = curry(_bimap);\n\n//chain :: Monad m => (a -> m b) -> m a -> m b\nconst _chain = (f: Function, m: Monad,): Monad =>{\n    if(!m.chain) throwError(\"chain not implemented\");\n    if(!isFunction(f)) throwError(\"function not provided\");\n    return m.chain.call(m, f);\n}\nconst chain = curry(_chain);\n\n//caseOf :: Object -> patternMatch -> a\nconst _caseOf = (o: Object, p: PatternMatch): any =>\n    !p.caseOf ? throwError(\"caseOf not implemented\") : p.caseOf(o);\nconst caseOf = curry(_caseOf);\n\n//liftAn :: Apply a => f -> Array<a> -> a \nconst _liftAn = (f: Function, fn: Array<Apply>) => {\n    if (!isFunction(f)) throwError(\"Function not found\");\n    if (fn.length <= 0) throwError(\"No Apply found!\");\n    const init: Apply = fn[0].map(f);\n    let res = init;\n    if (fn.length > 1) {\n        const rest = fn.slice(1);\n        res = rest.reduce((a: Apply, ca: Apply) => ca.ap(a), init);\n    }\n    return res;\n};\nconst _liftA1 = (f: Function, f1: Apply) => _liftAn(f, [f1]);\nconst _liftA2 = (f: Function, f1: Apply, f2: Apply) => _liftAn(f, [f1, f2]);\nconst _liftA3 = (f: Function, f1: Apply, f2: Apply, f3: Apply) =>\n    _liftAn(f, [f1, f2, f3]);\nconst _liftA4 = (f: Function, f1: Apply, f2: Apply, f3: Apply, f4: Apply) =>\n    _liftAn(f, [f1, f2, f3, f4]);\nconst _liftA5 = (\n    f: Function,\n    f1: Apply,\n    f2: Apply,\n    f3: Apply,\n    f4: Apply,\n    f5: Apply\n) => _liftAn(f, [f1, f2, f3, f4, f5]);\nconst liftAn = curry(_liftAn);\nconst liftA1 = curry(_liftA1);\nconst liftA2 = curry(_liftA2);\nconst liftA3 = curry(_liftA3);\nconst liftA4 = curry(_liftA4);\nconst liftA5 = curry(_liftA5);\n\nexport {\n    id,\n    isFunction,\n    throwError,\n    once,\n    fmap,\n    bimap,\n    chain,\n    caseOf,\n    curry,\n    ncurry,\n    compose,\n    liftAn,\n    liftA1,\n    liftA2,\n    liftA3,\n    liftA4,\n    liftA5\n};\n","import {Setoid, Semigroup, BiFunctor, Monad} from \"../interfaces\";\nimport {throwError, isFunction} from \"../functions/helpers\";\n\nconst _of = (v: any) =>{\n    return new Pair(v, v);\n}\n\nconst _pairs = new WeakMap();\nclass Pair implements Setoid, Semigroup, BiFunctor, Monad {\n\n    constructor(v1: any, v2: any){\n        if(v1 === undefined || v2 === undefined) throwError(\"Pair: Both first and second values must be defined\")\n        _pairs.set(this, [v1, v2]);\n    }\n\n    equals(j: Pair){\n        return j.fst() === this.fst() && j.snd() === this.snd();\n    }\n\n    // isEqual(n: any){\n    //     return this.equals(n);\n    // }\n\n    concat(p: Pair){\n        if(!(p instanceof Pair)) throwError(\"Pair: Pair required\");\n        const lf = this.fst()\n        const ls = this.snd()\n        const rf = p.fst()\n        const rs = p.snd()\n\n        if(!lf.concat || !ls.concat || !rf.concat || !rs.concat) throwError(\"Pair: Both Pairs must contain Semigroups\");\n\n        return new Pair(\n            lf.concat(rf),\n            ls.concat(rs)\n        );\n    }\n\n    of(v: any){\n        return _of(v);\n    }\n\n    fst(){\n        return this.getValue()[0];\n    }\n\n    snd(){\n        return this.getValue()[1];\n    }\n\n    ap(j: Pair): Pair{\n        if(!(j instanceof Pair)) throwError(\"Pair: Pair required\");\n        const fn = j.snd();\n        if(!isFunction(fn)) throwError(\"Pair: Second wrapped value should be a function\");\n        const l = this.fst();\n        const r = j.fst();\n        //console.log(l, r, fn);\n        if(!l.concat || !r.concat) throwError('Pair: Types should be Semigroups');\n      \n      return new Pair(l.concat(r), fn(this.snd()));\n    }\n\n    getValue(){\n        return _pairs.get(this);\n    }\n\n    map(f: Function){\n        if(!isFunction(f)) throwError(\"Pair: Expected a function\");\n        return new Pair(this.fst(), f(this.snd()));\n    }\n\n    bimap(f1: Function, f2:Function){\n        if(!isFunction(f1) || !isFunction(f2)) throwError(\"Pair: Expected functions for both parts\");\n        return new Pair(f1(this.fst()), f2(this.snd()));\n    }\n\n    chain(f: Function){\n        if(!isFunction(f)) throwError(\"Pair: Expected a function\");\n        const l = this.fst();\n        if(!l.concat) throwError(\"Pair: First value should be a Semigroup\");\n        const p = f(this.snd());\n        if(!(p instanceof Pair)) throwError(\"Pair: Function must return a Pair\");\n        const r = p.fst();\n        if(!r.concat) throwError(\"Pair: First value of the returned Pair should be a Semigroup\");\n\n        return new Pair(\n            l.concat(r),\n            p.snd()\n        );\n    }\n\n    swap() {\n        const v = this.getValue();\n        return new Pair(v[1], v[0]);\n    }\n\n    toString(){\n        const v = this.getValue();\n        return `Pair((${v[0]}), (${v[1]}))`;\n    }\n\n}\n\nPair.prototype.of = _of;\n\nexport default Pair;","import PairType from \"./pair-type\"\n\nconst Pair: any = (v1: any, v2: any) => new PairType(v1, v2);\nPair.of = PairType.prototype.of;\n\nexport default Pair;","import {Setoid, Monad, PatternMatch, BiFunctor} from \"../interfaces\";\nimport {throwError, isFunction} from \"../functions/helpers\";\n\nconst _lefts = new WeakMap();\nclass Left implements Setoid, BiFunctor, Monad, PatternMatch {\n\n    constructor(v: any){\n        _lefts.set(this, v);\n    }\n\n    equals(n: Setoid): boolean{\n       return n instanceof Left && n.isLeft && n.isLeft() && n.getValue() === this.getValue();\n    }\n\n    // isEqual(n: any){\n    //     return this.equals(n);\n    // }\n\n    of(v: any){\n        return new Left(v);\n    }\n\n    ap(n: Left){\n        return this;\n    }\n\n    getValue(){\n        return _lefts.get(this);\n    }\n\n    map(f: Function){\n        return this;\n    }\n\n    bimap(f: Function, _:Function): Left{\n        return this.of(f(this.getValue()))\n    }\n\n    chain(f: Function){\n        return this;\n    }\n\n    isRight(){\n        return false;\n    }\n\n    isLeft(){\n        return true;\n    }\n\n    swap(){\n        return new Right(this.getValue());\n    }\n\n    toString(){\n        return `Left(${this.getValue()})`;\n    }\n\n    caseOf(o: {Left: Function}){\n        return o.Left ? o.Left(this.getValue()) : throwError(\"Either: Expected Left!\");\n    }\n}\n\nconst _rights = new WeakMap();\nclass Right implements Setoid, BiFunctor, Monad, PatternMatch {\n\n    constructor(v: any){\n        _rights.set(this, v);\n    }\n\n    equals(j: Setoid): boolean{\n        return j instanceof Right && j.isRight && j.isRight() && j.getValue() === this.getValue();\n    }\n\n    // isEqual(n: any){\n    //     return this.equals(n);\n    // }\n\n    of(v: any){\n        return new Right(v);\n    }\n\n    ap(j: Right | Left): Right | Left{\n        if(!isFunction(j.getValue())) throwError(\"Either: Wrapped value is not a function\");\n        return this.map(j.getValue());\n    }\n\n    getValue(){\n        return _rights.get(this);\n    }\n\n    map(f: Function){\n        if(!isFunction(f)) throwError(\"Either: Expected a function\");\n        return new Right(f(this.getValue()));\n    }\n\n    bimap(_: Function, f:Function): Right{\n        return this.of(f(this.getValue()))\n    }\n\n    chain(f: Function){\n        if(!isFunction(f)) throwError(\"Either: Expected a function\");\n        return f(this.getValue());\n    }\n\n    isRight(){\n        return true;\n    }\n\n    isLeft(){\n        return false;\n    }\n\n    swap(){\n        return new Left(this.getValue());\n    }\n\n    toString(){\n        return `Right(${this.getValue()})`;\n    }\n\n    caseOf(o: {Right: Function}){\n        return o.Right ? o.Right(this.getValue()) : throwError(\"Either: Expected Right\");\n    }\n}\n\nconst Either = {\n    of: (v: any) => new Right(v),\n    Right: (v: any): Right => new Right(v),\n    Left: (v: any): Left => new Left(v),\n    fromNullable: (v: any): Right | Left => v ? new Right(v) : new Left(v),\n    withDefault: (def: any, v: any): Right => v ? new Right(v) : new Right(def),\n    swap: (e: Left | Right) => e.swap(),\n    try: (f: Function) => (...args: Array<any>) =>{\n        try {\n            return new Right(f.apply(null, args));\n        } catch (error) {\n            return new Left(error);\n        }\n    },\n    bimap: (e: Left | Right, fl: Function, fr: Function): Left | Right => e.bimap(fl, fr),\n    isLeft: (v: Left | Right) => v.isLeft && v.isLeft(),\n    isRight: (v: Left | Right) => v.isRight && v.isRight()\n    //catMaybes: (ar: Array<Right|Left>): Array<any> => ar.filter( m => m instanceof Right).map(m => m.getValue())\n    // partitionEithers: \n}\n\nexport default Either;","// import Functor from \"../implements/functor\";\n// import Monad from \"../implements/monad\";\n// import PatternMatch from \"../implements/patternmatch\";\nimport {Setoid, Monad, PatternMatch} from \"../interfaces\";\nimport {throwError, isFunction} from \"../functions/helpers\";\n\nclass Nothing implements Setoid, Monad, PatternMatch {\n\n    equals(n: Setoid): boolean{\n       return n instanceof Nothing && n.isNothing && n.isNothing();\n    }\n\n    // isEqual(n: Nothing){\n    //     return this.equals(n);\n    // }\n\n    of(v: any){\n        return new Nothing();\n    }\n\n    ap(n: Nothing){\n        return this;\n    }\n\n    getValue(){\n        return null;\n    }\n\n    map(f: Function){\n        return this;\n    }\n\n    chain(f: Function){\n        return this\n    }\n\n    isJust(){\n        return false;\n    }\n\n    isNothing(){\n        return true;\n    }\n\n    toString(){\n        return \"Nothing()\";\n    }\n\n    caseOf(o: {Nothing: Function}){\n        return o.Nothing ? o.Nothing() : throwError(\"Maybe: Expected Nothing!\");\n    }\n}\n\nconst _justs = new WeakMap();\nclass Just implements Setoid, Monad, PatternMatch {\n\n    constructor(v: any){\n        _justs.set(this, v);\n    }\n\n    equals(j: Setoid): boolean{\n        return j instanceof Just && j.isJust && j.isJust() && j.getValue() === this.getValue();\n    }\n\n    // isEqual(n: Just){\n    //     return this.equals(n);\n    // }\n\n    of(v: any){\n        return new Just(v);\n    }\n\n\n    ap(j: Just | Nothing): Just | Nothing{\n        if(!isFunction(j.getValue())) throwError(\"Maybe: Wrapped value is not a function\");\n        return this.map(j.getValue());\n    }\n\n    getValue(){\n        return _justs.get(this);\n    }\n\n    map(f: Function){\n        if(!isFunction(f)) throwError(\"Maybe: Expected a function\");\n        return new Just(f(this.getValue()));\n    }\n\n    chain(f: Function){\n        if(!isFunction(f)) throwError(\"Maybe: Expected a function\");\n        return f(this.getValue());\n    }\n\n    isJust(){\n        return true;\n    }\n\n    isNothing(){\n        return false;\n    }\n\n    toString(){\n        return `Just(${this.getValue()})`;\n    }\n\n    caseOf(o: {Just: Function}){\n        return o.Just ? o.Just(this.getValue()) : throwError(\"Maybe: Expected Just\");\n    }\n}\n\nconst Maybe = {\n    of: (v: any) => new Just(v),\n    zero: () => new Nothing(),\n    Just: (v: any): Just => new Just(v),\n    Nothing: (v?: any): Nothing => new Nothing(),\n    fromNullable: (v: any): Just | Nothing => v ? new Just(v) : new Nothing(),\n    withDefault: (def: any, v: any): Just => v ? new Just(v) : new Just(def),\n    catMaybes: (ar: Array<Just|Nothing>): Array<any> => ar.filter( m => m instanceof Just).map(m => m.getValue()),\n    isJust: (v: Just| Nothing) => v.isJust(),\n    isNothing: (v: Just| Nothing) => v.isNothing()\n}\n\nexport default Maybe;","\nimport {Monad, Semigroup} from \"../interfaces\";\nimport {once, compose, throwError, isFunction} from \"../functions/helpers\";\n\nconst _of = (v: any) => {\n    return new Task((_: any, resolve: Function) => resolve(v));\n};\n\nconst _rejected = (v: any) => {\n    return new Task((rej: Function, _: Function) => rej(v))\n}\n\nconst _tasks = new WeakMap();\nclass Task implements Semigroup, Monad {\n\n    constructor(f: Function/*, cancel: Function*/){\n        isFunction(f) ? _tasks.set(this, f) : throwError(\"Task: Expected a Function\");\n        //cancel && isFunction(cancel) ? _cancels.set(this, cancel) : _cancels.set(this, function(){})\n    }\n\n    fork(reject: Function, resolve: Function){\n        if(!isFunction(resolve) || !isFunction(reject)) throwError(\"Task: Reject and Resolve need to be functions\");\n        const fn = this.getValue();\n        fn(reject, resolve);\n    }\n\n    of(v: any) {\n        return _of(v);\n    }\n\n    rejected(v: any) {\n        return _rejected(v);\n    }\n\n    toString(){\n        const fork = this.getValue();\n        return `Task(${fork.toString()})`;\n    }\n\n    map(f: Function){\n        if(!isFunction(f)) throwError(\"Task: Expected a function\");\n        const fork = this.getValue();\n        return new Task((rej: Function, res: Function) => fork(rej, compose(res, f)));\n    }\n\n    getValue(){\n        return _tasks.get(this);\n    }\n\n    ap(t: Task){\n        if(!(t instanceof Task)) throwError(\"Task: type mismatch\");\n        const thisFork = this.getValue();\n        let value: Array<any>;\n        let fn: Function;\n        let gotValues: boolean = false;\n        let gotFuction: boolean = false;\n        let rejected: boolean = false;\n\n        return new Task((rej: Function, res: Function) => {\n            const rejOnce = compose(() => {rejected = true;}, once(rej));\n\n            const resolveBoth = () => {\n                if(gotValues && gotFuction && !rejected){\n                    const exec = compose(res, fn);\n                    exec.apply(null, value);\n                }\n            }\n\n            thisFork(rejOnce, (...values: Array<any>) => {\n                value = values;\n                gotValues = true;\n                resolveBoth();\n            })\n\n            t.fork(rejOnce, (f: Function) => {\n                if(!isFunction(f)) throwError(\"Task: Wrapped value should be a function\");\n                fn = f;\n                gotFuction = true;\n                resolveBoth();\n            });\n        })\n    }\n\n    concat(t: Task) {\n        if(!(t instanceof Task)) throwError(\"Task: type mismatch\");\n        const thisFork = this.getValue();\n        const thatFork = t.getValue();\n\n        return new Task((rej: Function, res: Function) => {\n            let rejected: boolean = false;\n            const rejOnce = compose(() => {rejected = true;}, once(rej));\n            let result1: any;\n            let result2: any;\n\n            const resolveBoth = () => {\n                if(result1 && result2 && !rejected){\n                    res.apply(null, [...result1, ...result2]);\n                }\n            }\n\n            thisFork(rejOnce, (...values: Array<any>) => {\n                result1 = values;\n                resolveBoth();\n            });\n\n            thatFork(rejOnce, (...values: Array<any>) => {\n                result2 = values;\n                resolveBoth();\n            })\n        });\n    }\n\n    chain(f: Function){\n        if(!isFunction(f)) throwError(\"Task: Function required\");\n        const thisFork = this.getValue();\n        \n        return new Task((rej: Function, res: Function) => {\n            thisFork(rej, (...args: Array<any>) => {\n                const t = f.call(null, args);\n                if(!(t instanceof Task)) throwError(\"Task: function must return another Task\");\n                t.fork(rej, res);\n            })\n        });\n    }\n    \n    toPromise(){\n        const thisFork = this.getValue();\n        return new Promise((res, rej) => {\n            thisFork(rej, res);\n        });\n    }\n}\n\nTask.prototype.of = _of;\nTask.prototype.rejected = _rejected;\n\nexport default Task;","import TaskType from \"./task-type\"\n\nconst Task: any = (f: Function) => new TaskType(f);\nTask.of = TaskType.prototype.of;\nTask.rejected = TaskType.prototype.rejected;\n\nexport default Task;","import {\n    id,\n    once,\n    fmap,\n    bimap,\n    chain,\n    caseOf,\n    curry,\n    ncurry,\n    compose,\n    liftAn,\n    liftA1,\n    liftA2,\n    liftA3,\n    liftA4,\n    liftA5\n} from \"./functions/helpers\"\n\nimport Pair from \"./data-types/pair\";\nimport Either from \"./data-types/either\";\nimport Maybe from \"./data-types/maybe\";\nimport Task from \"./data-types/task\";\n\n\n//Algebraic Data Types\n\nexport default {\n    id,\n    once,\n    fmap,\n    bimap,\n    chain,\n    caseOf,\n    curry,\n    ncurry,\n    compose,\n    liftAn,\n    liftA1,\n    liftA2,\n    liftA3,\n    liftA4,\n    liftA5,\n    Pair,\n    Either,\n    Maybe,\n    Task\n};\n"],"names":["slice","Array","prototype","throwError","x","id","isFunction","f","once","_called","_result","undefined","_i","apply","args","curry","fn","arity","length","call","arguments","curried","concat","ncurry","ar","curArgs","Object","keys","diff","filter","indexOf","ar2","assign","compose","fns","reduce","g","_fmap","map","fmap","_bimap","f1","f2","b","bimap","_chain","m","chain","_caseOf","o","p","caseOf","_liftAn","init","res","rest","a","ca","ap","_liftA1","_liftA2","_liftA3","f3","_liftA4","f4","_liftA5","f5","liftAn","liftA1","liftA2","liftA3","liftA4","liftA5","_of","v","Pair","_pairs","WeakMap","v1","v2","set","j","fst","snd","lf","ls","rf","rs","getValue","l","r","get","of","PairType","_lefts","n","Left","isLeft","_","Right","_rights","isRight","Either","def","e","swap","error","fl","fr","Nothing","isNothing","_justs","Just","isJust","Maybe","Task","resolve","_rejected","rej","_tasks","reject","fork","toString","t","thisFork","value","gotValues","gotFuction","rejected","rejOnce","resolveBoth","exec","values","thatFork","result1","result2","Promise","TaskType"],"mappings":"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"}