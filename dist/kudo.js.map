{"version":3,"file":"kudo.js","sources":["../src/data-types/either.ts","../src/data-types/maybe.ts","../src/functions/helpers.ts","../src/data-types/pair-type.ts","../src/data-types/pair.ts","../src/data-types/task-type.ts","../src/data-types/task.ts","../src/index.ts"],"sourcesContent":["import { Setoid, Monad, PatternMatch, BiFunctor } from \"../interfaces\";\nimport { caseOf, throwError, isFunction } from \"../functions/helpers\";\n\nabstract class Either<A, B> implements Setoid, BiFunctor<A, B>, Monad<B>, PatternMatch{\n\n  _value: A | B;\n\n  abstract equals(n: Setoid): boolean;\n  abstract map<C>(f: (a: B) => C): Either<A, C>;\n  abstract bimap<C, D>(fl: (a: A) => C, fr: (a: B) => D): Either<C, D>\n  abstract chain<C>(f: (a: B) => Either<A, C>): Either<A, C>\n  abstract caseOf(o: {Left: Function}| {Right: Function}): any;\n  abstract swap(): Either<A, B>;\n  abstract isLeft(): boolean;\n  abstract isRight(): boolean;\n\n  static of<A, B>(v: B): Either<A, B>{\n    return new Right(v);\n  }\n\n  static Right<A, B>(v: B): Either<A, B> {\n    return new Right(v);\n  }\n\n  static Left<A, B>(v: A): Either<A, B> {\n    return new Left(v);\n  }\n  \n  static fromNullable<A, B>(v: any): Either<A, B> {\n    return (v ? new Right(v) : new Left(v));\n  }\n\n  static withDefault<A, B>(def: any, v: any): Either<A, B> {\n    return v ? new Right(v) : new Right(def);\n  }\n\n  static swap<A,B>(e: Either<A,B>){\n    return e.swap();\n  }\n\n  static try(f: Function) {\n    return <A,B>(...args: Array<any>): Either<A, B> => {\n      try {\n        return new Right<A, B>(f.apply(null, args));\n      } catch (e) {\n        return new Left<A, B>(e);\n      }\n    }\n  }\n\n  static bimap<A, B, C, D>(e: Either<A,B>, fl: (a: A) => C, fr: (a: B) => D) {\n    return e.bimap(fl, fr);\n  }\n\n  static isLeft<A, B>(v: Either<A, B>): boolean{\n    return v.isLeft();\n  }\n\n  static isRight<A, B>(v: Either<A, B>): boolean{\n    return v.isRight();\n  }\n\n  of<B>(v: B): Either<A, B>{\n    return new Right(v);\n  }\n\n  ap<C>(j: Either<A, (a: B) => C>): Either<B, C> {\n    if (!isFunction(j.getValue()))\n      throwError(\"Either: Wrapped value is not a function\");\n    \n    return caseOf({\n      Left: (v: A) => j,\n      Right: (v: (a: B) => C) => this.map(v)\n    }, j);\n  }\n\n  getValue(): A | B {\n    return this._value;\n  }\n\n}\n// @ts-ignore: implicit any\nEither.prototype['fantasy-land/equals'] = Either.prototype.equals;\n// @ts-ignore: implicit any\nEither.prototype['fantasy-land/map'] = Either.prototype.map;\n// @ts-ignore: implicit any\nEither.prototype['fantasy-land/bimap'] = Either.prototype.bimap;\n// @ts-ignore: implicit any\nEither.prototype['fantasy-land/chain'] = Either.prototype.chain;\n// @ts-ignore: implicit any\nEither.prototype['fantasy-land/of'] = Either.prototype.of;\n// @ts-ignore: implicit any\nEither.prototype['fantasy-land/ap'] = Either.prototype.ap;\n\nclass Left<A, B> extends Either<A,B> {\n  \n  constructor(v: A) {\n    super();\n    this._value = v;\n  }\n\n  equals(n: Setoid): boolean {\n    return (\n      n instanceof Left &&\n      n.isLeft &&\n      n.isLeft() &&\n      n.getValue() === this.getValue()\n    );\n  }\n\n  map<C>(f: (a: B) => C): Either<A, C> {\n    return new Left<A, C>(<A>this.getValue());\n  }\n\n  bimap<C, D>(fl: (a: A) => C, fr: (a: B) => D): Either<C, D> {\n    return new Left(fl(<A>this.getValue()));\n  }\n\n  chain<C>(f: (a: B) => Either<A, C>): Either<A, C> {\n    return new Left<A,C>(<A>this.getValue());\n  }\n\n  isRight() {\n    return false;\n  }\n\n  isLeft() {\n    return true;\n  }\n\n  swap(): Either<A, B> {\n    return new Right<A, B>(<B>this.getValue());\n  }\n\n  toString() {\n    return `Left(${this.getValue()})`;\n  }\n\n  caseOf(o: { Left: Function }) {\n    return o.Left\n      ? o.Left(this.getValue())\n      : throwError(\"Either: Expected Left!\");\n  }\n}\n\nclass Right<A,B> extends Either<A, B> {\n  \n  constructor(v: B) {\n    super();\n    this._value = v;\n  }\n\n  equals(j: Setoid): boolean {\n    return (\n      j instanceof Right &&\n      j.isRight &&\n      j.isRight() &&\n      j.getValue() === this.getValue()\n    );\n  }\n\n  map<C>(f: (a: B) => C): Either<A, C> {\n    if (!isFunction(f)) throwError(\"Either: Expected a function\");\n    return new Right<A, C>(f(<B>this.getValue()));\n  }\n\n  bimap<C, D>(fl: (a: A) => C, fr: (a: B) => D): Either<C, D>{\n    return new Right(fr(<B>this.getValue()));\n  }\n\n  chain<C>(f: (a: B) => Either<A, C>): Either<A, C> {\n    if (!isFunction(f)) throwError(\"Either: Expected a function\");\n    return f(<B>this.getValue());\n  }\n\n  isRight() {\n    return true;\n  }\n\n  isLeft() {\n    return false;\n  }\n\n  swap(): Either<A, B> {\n    return new Left<A, B>(<A>this.getValue());\n  }\n\n  toString() {\n    return `Right(${this.getValue()})`;\n  }\n\n  caseOf(o: { Right: Function }) {\n    return o.Right\n      ? o.Right(this.getValue())\n      : throwError(\"Either: Expected Right\");\n  }\n}\n\nexport default Either;\n","import { Setoid, Monad, Alt, PatternMatch } from \"../interfaces\";\nimport { throwError, isFunction, caseOf } from \"../functions/helpers\";\n\nexport default abstract class Maybe<A> implements Setoid, Monad<A>, Alt<A>, PatternMatch {\n\n  _value: A\n\n  abstract equals(n: Setoid): boolean;\n  abstract map<B>(f: (a: A) => B): Maybe<B>;\n  abstract chain<B>(f: (a: A) => Maybe<B>): Maybe<B>;\n  abstract caseOf(o: {Nothing: Function}| {Just: Function}): any;\n  abstract isNothing(): boolean;\n  abstract isJust(): boolean;\n\n  static of<A>(v: A): Maybe<A>{\n    return new Just(v);\n  }\n\n  static zero<A>(): Maybe<A>{\n    return new Nothing();\n  }\n\n  static Just<A>(v: A): Maybe<A>{\n    return new Just(v);\n  }\n\n  static Nothing<A>(): Maybe<A>{\n    return new Nothing();\n  }\n\n  static fromNullable<A>(v: any): Maybe<A> {\n    return (v ? new Just(v) : new Nothing());\n  }\n\n  static withDefault<A>(def: any, v: any): Maybe<A> {\n    return v ? new Just(v) : new Just(def);\n  }\n\n  static catMaybes<A>(ar: Array<Maybe<A>>): Array<any> {\n    return ar.filter(m => m.isJust()).map(m => m.getValue())\n  }\n\n  static isNothing<A>(v: Maybe<A>): boolean{\n    return v.isNothing();\n  }\n\n  static isJust<A>(v: Maybe<A>): boolean{\n    return v.isJust();\n  }\n\n  of<A>(v: A): Maybe<A>{\n    return new Just(v);\n  }\n\n  alt<B>(v: Maybe<B>): Maybe<B>{\n    return caseOf({\n      Nothing: (x: any) => v,\n      Just: (x: any) => this\n    }, this)\n  }\n\n  ap<B>(j: Maybe<(a: A) => B>): Maybe<B> {\n    if (!isFunction(j.getValue()))\n      throwError(\"Maybe: Wrapped value is not a function\");\n    \n    return caseOf({\n      Nothing: (v: A) => j,\n      Just: (v: (a: A) => B) => this.map(v)\n    }, j);\n  }\n\n  getValue(): A{\n    return this._value;\n  }\n}\n// @ts-ignore: implicit any\nMaybe.prototype['fantasy-land/equals'] = Maybe.prototype.equals;\n// @ts-ignore: implicit any\nMaybe.prototype['fantasy-land/map'] = Maybe.prototype.map;\n// @ts-ignore: implicit any\nMaybe.prototype['fantasy-land/chain'] = Maybe.prototype.chain;\n// @ts-ignore: implicit any\nMaybe.prototype['fantasy-land/of'] = Maybe.prototype.of;\n// @ts-ignore: implicit any\nMaybe.prototype['fantasy-land/zero'] = Maybe.prototype.zero;\n// @ts-ignore: implicit any\nMaybe.prototype['fantasy-land/ap'] = Maybe.prototype.ap;\n\nexport class Nothing<A> extends Maybe<A> {\n  equals(n: Setoid): boolean {\n    return n instanceof Nothing && n.isNothing && n.isNothing();\n  }\n\n  map<B>(f: (a: A) => B): Maybe<B> {\n    return new Nothing();\n  }\n\n  chain<B>(f: (a: A) => Maybe<B>): Maybe<B> {\n    return new Nothing();\n  }\n\n  isJust() {\n    return false;\n  }\n\n  isNothing() {\n    return true;\n  }\n\n  toString() {\n    return \"Nothing()\";\n  }\n\n  caseOf(o: { Nothing: Function }) {\n    return o.Nothing ? o.Nothing() : throwError(\"Maybe: Expected Nothing!\");\n  }\n}\n\nexport class Just<A> extends Maybe<A> {\n  constructor(v: any) {\n    super();\n    this._value = v;\n  }\n\n  equals(j: Setoid): boolean {\n    return (\n      j instanceof Just &&\n      j.isJust &&\n      j.isJust() &&\n      j.getValue() === this.getValue()\n    );\n  }\n\n  map<B>(f: (a: A) => B): Maybe<B> {\n    if (!isFunction(f)) throwError(\"Maybe: Expected a function\");\n    return new Just(f(this.getValue()));\n  }\n\n  chain<B>(f: (a: A) => Maybe<B>): Maybe<B> {\n    if (!isFunction(f)) throwError(\"Maybe: Expected a function\");\n    return f(this.getValue());\n  }\n\n  isJust() {\n    return true;\n  }\n\n  isNothing() {\n    return false;\n  }\n\n  toString() {\n    return `Just(${this.getValue()})`;\n  }\n\n  caseOf(o: { Just: Function }) {\n    return o.Just\n      ? o.Just(this.getValue())\n      : throwError(\"Maybe: Expected Just\");\n  }\n}\n","import { Functor, Monad, Apply, BiFunctor, PatternMatch } from \"../interfaces\";\nimport Either from \"../data-types/either\";\nimport Maybe from \"../data-types/maybe\";\n\nconst slice = Array.prototype.slice;\n\n/** @function throwError\n * @param {string} x - Error message\n * @description Throw an error\n */\nconst throwError = (x: String) => {\n  throw x;\n};\n\n/** @function id\n * @param {*} x - Any\n * @description Identity Function\n */\nconst id = (x: any): any => x;\n\n/** @function isFunction\n * @param {*} f - Any\n * @description Check if supplied argument is\n */\nconst isFunction = (f: any) => typeof f === \"function\";\n\n/** @function once\n * @param {Function} f - Function to be called once\n * @description Create a function which calls the given function only once\n */\nconst once = (f: Function) => {\n  if (!isFunction(f)) throwError(\"Function not provided\");\n  let _called = false;\n  let _result: any = undefined;\n\n  return (...args: Array<any>) => {\n    if (!_called) {\n      _called = true;\n      _result = f.apply(null, args);\n    }\n    return _result;\n  };\n};\n\n/** @function curry\n * @param {Function} f - Function to be curried\n * @description Returns a curried equivalent of the provided function.\n */\nconst curry = (fn: Function): Function => {\n  if (!isFunction(fn)) throwError(\"Function not provided\");\n\n  const arity = fn.length;\n  return function curried() {\n    let args = slice.call(arguments, 0);\n    if (args.length >= arity) return fn.apply(null, args);\n\n    return function() {\n      return curried.apply(null, args.concat(slice.call(arguments)));\n    };\n  };\n};\n\n/** @function ncurry\n * @param {Function} fn - Function to be curried which accepts a single named argument object\n * @param {Array<string>} args - key names of the Function argument object\n * @description Returns a curried equivalent of the provided function which will accept named arguments in any order\n */\nconst ncurry = (fn: Function, args: Array<string>): Function => {\n  if (!isFunction(fn)) throwError(\"Function not provided\");\n  if (fn.length > 1) throwError(\"Function Arity cannot be greater than 1\");\n  //if (typeof fn.arguments[0] !== \"object\") return throwError(\"Function argument must be an object type\");\n  //const args = Object.keys(fn.arguments[0]);\n\n  return function curried(ar: Object): Function {\n    const curArgs = Object.keys(ar);\n    const diff = args.filter(x => curArgs.indexOf(x) < 0);\n    if (diff.length > 0)\n      return (ar2: Object): Function =>\n        curried.call(null, (<any>Object).assign({}, ar, ar2));\n    return fn.call(null, ar);\n  };\n};\n\n/** @function compose\n * @param {...Function} fns - functions to compose\n * @description Performs right-to-left function composition.\n * @summary compose :: Function\n */\nconst compose = (...fns: Array<Function>): Function => {\n  if (fns.length <= 0) throwError(\"Nothing to compose!\");\n  return fns.reduce((f, g) => (...args: Array<any>) => f(g(...args)));\n};\n\n/** @function fmap\n * @param {Function} fn - functions to be mapped\n * @param {Functor} f - Functor\n * @description Takes a function and a functor, applies the function to each of the functor's values, and returns a functor\n * @summary fmap :: Functor f => (a → b) → f a → f b\n */\nconst _fmap = (fn: Function, f: Functor): Functor => {\n  if (!isFunction(fn)) throwError(\"function not provided\");\n  if (!f.map) throwError(\"Functor not found\");\n  return f.map.call(f, fn);\n};\nconst fmap = curry(_fmap);\n\n/** @function bimap\n * @param {Function} f1 - function to be mapped on left\n * @param {Function} f2 - function to be mapped on right\n * @param {BiFunctor} b - BiFunctor\n * @description Apply the first argument function to the left and the second argument function to a right of Bifunctor.\n * @summary bimap :: BiFunctor b => b a c ~> (a -> e) -> (c -> d) ->  b a c -> b e d\n */\nconst _bimap = (f1: Function, f2: Function, b: BiFunctor): BiFunctor => {\n  if (!isFunction(f1) || !isFunction(f2)) throwError(\"Functions not provided\");\n  if (!b.bimap) throwError(\"BiFunctor not found\");\n  return b.bimap(f1, f2);\n};\nconst bimap = curry(_bimap);\n\n/** @function chain\n * @param {Function} fn - function that returns a monad\n * @param {Monad} m - Functor\n * @description Chain together in many computations\n * @summary chain :: Monad m => (a -> m b) -> m a -> m b\n */\nconst _chain = (f: Function, m: Monad): Monad => {\n  if (!m.chain) throwError(\"chain not implemented\");\n  if (!isFunction(f)) throwError(\"function not provided\");\n  return m.chain.call(m, f);\n};\nconst chain = curry(_chain);\n\n/** @function caseOf\n * @param {Object} o - Pattern match id as Key and function as value\n * @param {PatternMatch} p - Pattern Match Object\n * @description match an expression to a pattern. When a match is found, it evaluates the expression and returns whatever value is produced.\n * @summary caseOf :: Object -> patternMatch -> a\n */\nconst _caseOf = (o: Object, p: PatternMatch): any =>\n  !p.caseOf ? throwError(\"unable to match patterns\") : p.caseOf(o);\nconst caseOf = curry(_caseOf);\n\n\nconst _liftAn = (f: Function, fn: Array<Apply>) => {\n  if (!isFunction(f)) throwError(\"Function not found\");\n  if (fn.length <= 0) throwError(\"No Apply found!\");\n  const init: Apply = fn[0].map(f);\n  let res = init;\n  if (fn.length > 1) {\n    const rest = fn.slice(1);\n    res = rest.reduce((a: Apply, ca: Apply) => ca.ap(a), init);\n  }\n  return res;\n};\nconst _liftA1 = (f: Function, f1: Apply) => _liftAn(f, [f1]);\nconst _liftA2 = (f: Function, f1: Apply, f2: Apply) => _liftAn(f, [f1, f2]);\nconst _liftA3 = (f: Function, f1: Apply, f2: Apply, f3: Apply) =>\n  _liftAn(f, [f1, f2, f3]);\nconst _liftA4 = (f: Function, f1: Apply, f2: Apply, f3: Apply, f4: Apply) =>\n  _liftAn(f, [f1, f2, f3, f4]);\nconst _liftA5 = (\n  f: Function,\n  f1: Apply,\n  f2: Apply,\n  f3: Apply,\n  f4: Apply,\n  f5: Apply\n) => _liftAn(f, [f1, f2, f3, f4, f5]);\n\n/** @function liftAn\n * @param {Function} f - Function to be lifted\n * @param {...Apply} fn - Applys to the function\n * @description lets us combine n separate wrapped values into one with a given function.\n */\nconst liftAn = curry(_liftAn);\n\n/** @function liftA1\n * @param {Function} f - Function to be lifted\n * @param {Apply} fn - 'Apply' to the function\n * @description Aka fmap\n */\nconst liftA1 = curry(_liftA1);\n\n/** @function liftA2\n * @param {Function} f - Function to be lifted\n * @param {Apply} f1 - 'Apply' to the function\n * @param {Apply} f2 - 'Apply' to the function\n * @description lets us combine 2 separate wrapped values into one with a given function.\n */\nconst liftA2 = curry(_liftA2);\n\n/** @function liftA3\n * @param {Function} f - Function to be lifted\n * @param {Apply} f1 - 'Apply' to the function\n * @param {Apply} f2 - 'Apply' to the function\n * @param {Apply} f3 - 'Apply' to the function\n * @description lets us combine 3 separate wrapped values into one with a given function.\n */\nconst liftA3 = curry(_liftA3);\n\n/** @function liftA4\n * @param {Function} f - Function to be lifted\n * @param {Apply} f1 - 'Apply' to the function\n * @param {Apply} f2 - 'Apply' to the function\n * @param {Apply} f3 - 'Apply' to the function\n * @param {Apply} f4 - 'Apply' to the function\n * @description lets us combine 4 separate wrapped values into one with a given function.\n */\nconst liftA4 = curry(_liftA4);\n\n/** @function liftA2\n * @param {Function} f - Function to be lifted\n * @param {Apply} f1 - 'Apply' to the function\n * @param {Apply} f2 - 'Apply' to the function\n * @param {Apply} f3 - 'Apply' to the function\n * @param {Apply} f4 - 'Apply' to the function\n * @param {Apply} f5 - 'Apply' to the function\n * @description lets us combine 2 separate wrapped values into one with a given function.\n */\nconst liftA5 = curry(_liftA5);\n\n/** @function maybeToEither\n * @param {Maybe} m - Maybe type\n * @description Converts a Maybe type to an Either Type\n */\nconst maybeToEither = <A>(m: Maybe<A>) => caseOf({\n  Nothing: (v: any) => Either.Left(null),\n  Just: (v: any) => Either.Right(v)\n}, m);\n\n/** @function eitherToMaybe\n * @param {Maybe} m - Maybe type\n * @description Converts a Maybe type to an Either Type\n */\nconst eitherToMaybe = <A, B>(e: Either<A, B>) => caseOf({\n  Left: (v: any) => Maybe.Nothing(),\n  Right: (v: any) => Maybe.Just(v)\n}, e);\n\nexport {\n  id,\n  isFunction,\n  throwError,\n  once,\n  fmap,\n  bimap,\n  chain,\n  caseOf,\n  curry,\n  ncurry,\n  compose,\n  liftAn,\n  liftA1,\n  liftA2,\n  liftA3,\n  liftA4,\n  liftA5,\n  maybeToEither,\n  eitherToMaybe\n};\n","import { Setoid, Semigroup, BiFunctor, Monad } from \"../interfaces\";\nimport { throwError, isFunction } from \"../functions/helpers\";\n\nclass Pair<A, B> implements Setoid, Semigroup, BiFunctor, Monad {\n\n  _value: Array<A | B>\n\n  constructor(v1: A, v2: B) {\n    if (v1 === undefined || v2 === undefined)\n      throwError(\"Pair: Both first and second values must be defined\");\n    // _pairs.set(this, [v1, v2]);\n    this._value = [v1, v2];\n  }\n\n  static of<A>(v: A) {\n    return new Pair(v, v);\n  }\n\n  of<A>(v: A) {\n    return new Pair(v, v);\n  }\n\n  equals(j: Pair<A, B>) {\n    return <A>j.fst() === <A>this.fst() && <B>j.snd() === <B>this.snd();\n  }\n\n  concat(p: Pair<Semigroup, Semigroup>): Pair<A, B>{\n    if (!(p instanceof Pair)) throwError(\"Pair: Pair required\");\n    const lf: any = this.fst();\n    const ls: any = this.snd();\n    const rf = p.fst();\n    const rs = p.snd();\n\n    if (!lf.concat || !ls.concat || !rf.concat || !rs.concat)\n      throwError(\"Pair: Both Pairs must contain Semigroups\");\n\n    return new Pair(lf.concat(rf), ls.concat(rs));\n  }\n\n  fst(): A {\n    return <A>this.getValue()[0];\n  }\n\n  snd(): B {\n    return <B>this.getValue()[1];\n  }\n\n  ap<C, D>(j: Pair<C, (b: B) => D>): Pair<Semigroup, D> {\n    if (!(j instanceof Pair)) throwError(\"Pair: Pair required\");\n    const fn: any = j.snd();\n    if (!isFunction(fn))\n      throwError(\"Pair: Second wrapped value should be a function\");\n    const l: any = this.fst();\n    const r: any = j.fst();\n    //console.log(l, r, fn);\n    if (!l.concat || !r.concat) throwError(\"Pair: Types should be Semigroups\");\n\n    return new Pair(l.concat(r), fn(this.snd()));\n  }\n\n  getValue() {\n    return this._value;\n  }\n\n  map<C>(f: (a: B) => C): Pair<A, C> {\n    if (!isFunction(f)) throwError(\"Pair: Expected a function\");\n    return new Pair(<A>this.fst(), f(<B>this.snd()));\n  }\n\n  bimap<C, D>(f1: (a: A) => C, f2: (a: B) => D): Pair<C, D> {\n    if (!isFunction(f1) || !isFunction(f2))\n      throwError(\"Pair: Expected functions for both parts\");\n    return new Pair(f1(<A>this.fst()), f2(<B>this.snd()));\n  }\n\n  chain<C, D>(f: (a: B) => Pair<C, D>): Pair<C, D> {\n    if (!isFunction(f)) throwError(\"Pair: Expected a function\");\n    const l: any = this.fst();\n    if (!l.concat) throwError(\"Pair: First value should be a Semigroup\");\n    const p = f(<B>this.snd());\n    if (!(p instanceof Pair)) throwError(\"Pair: Function must return a Pair\");\n    const r: any = p.fst();\n    if (!r.concat)\n      throwError(\n        \"Pair: First value of the returned Pair should be a Semigroup\"\n      );\n\n    return new Pair(<C>l.concat(r), <D>p.snd());\n  }\n\n  swap() {\n    const v = this.getValue();\n    return new Pair(v[1], v[0]);\n  }\n\n  toString() {\n    const v = this.getValue();\n    return `Pair((${v[0]}), (${v[1]}))`;\n  }\n}\n\n// @ts-ignore: implicit any\nPair.prototype['fantasy-land/equals'] = Pair.prototype.equals;\n// @ts-ignore: implicit any\nPair.prototype['fantasy-land/map'] = Pair.prototype.map;\n// @ts-ignore: implicit any\nPair.prototype['fantasy-land/concat'] = Pair.prototype.concat;\n// @ts-ignore: implicit any\nPair.prototype['fantasy-land/bimap'] = Pair.prototype.bimap;\n// @ts-ignore: implicit any\nPair.prototype['fantasy-land/chain'] = Pair.prototype.chain;\n// @ts-ignore: implicit any\nPair.prototype['fantasy-land/of'] = Pair.prototype.of;\n// @ts-ignore: implicit any\nPair.prototype['fantasy-land/ap'] = Pair.prototype.ap;\n\nexport default Pair;\n","import PairType from \"./pair-type\"\n\nconst Pair: any = (v1: any, v2: any) => new PairType(v1, v2);\nPair.of = PairType.prototype.of;\n// @ts-ignore: implicit any\nPair.prototype['fantasy-land/of'] = PairType.prototype.of;\n\nexport default Pair;","import { Monad, Semigroup } from \"../interfaces\";\nimport { once, compose, throwError, isFunction } from \"../functions/helpers\";\n\nclass Task implements Semigroup, Monad {\n\n  _value: (rej: Function, res: Function) => any\n\n  constructor(f: (rej: Function, res: Function) => any) {\n    isFunction(f)\n      ? this._value = f\n      : throwError(\"Task: Expected a Function\");\n  }\n\n  static of(v: any) {\n    return new Task((_: Function, resolve: Function) => resolve(v));\n  }\n\n  static rejected(v: any){\n    return new Task((reject: Function, _: Function) => reject(v));\n  }\n\n  of(v: any) {\n    return new Task((_: Function, resolve: Function) => resolve(v));\n  }\n\n  rejected(v: any){\n    return new Task((reject: Function, _: Function) => reject(v));\n  }\n\n  fork(reject: Function, resolve: Function) {\n    if (!isFunction(resolve) || !isFunction(reject))\n      throwError(\"Task: Reject and Resolve need to be functions\");\n    const fn = this.getValue();\n    fn(reject, resolve);\n  }\n\n  toString() {\n    const fork = this.getValue();\n    return `Task(${fork.name})`;\n  }\n\n  map<A,B>(f: (a: A) => B): Task {\n    if (!isFunction(f)) throwError(\"Task: Expected a function\");\n    const fork = this.getValue();\n    return new Task((rej: Function, res: Function) =>\n      fork(rej, compose(res, f))\n    );\n  }\n\n  getValue() {\n    return this._value;\n  }\n\n  ap(t: Task) {\n    if (!(t instanceof Task)) throwError(\"Task: type mismatch\");\n    const thisFork = this.getValue();\n    let value: Array<any>;\n    let fn: Function;\n    let gotValues: boolean = false;\n    let gotFuction: boolean = false;\n    let rejected: boolean = false;\n\n    return new Task((rej: Function, res: Function) => {\n      const rejOnce = compose(() => {\n        rejected = true;\n      }, once(rej));\n\n      const resolveBoth = () => {\n        if (gotValues && gotFuction && !rejected) {\n          const exec = compose(res, fn);\n          exec.apply(null, value);\n        }\n      };\n\n      thisFork(rejOnce, (...values: Array<any>) => {\n        value = values;\n        gotValues = true;\n        resolveBoth();\n      });\n\n      t.fork(rejOnce, (f: Function) => {\n        if (!isFunction(f))\n          throwError(\"Task: Wrapped value should be a function\");\n        fn = f;\n        gotFuction = true;\n        resolveBoth();\n      });\n    });\n  }\n\n  concat(t: Task) {\n    if (!(t instanceof Task)) throwError(\"Task: type mismatch\");\n    const thisFork = this.getValue();\n    const thatFork = t.getValue();\n\n    return new Task((rej: Function, res: Function) => {\n      let rejected: boolean = false;\n      const rejOnce = compose(() => {\n        rejected = true;\n      }, once(rej));\n      let result1: any;\n      let result2: any;\n\n      const resolveBoth = () => {\n        if (result1 && result2 && !rejected) {\n          res.apply(null, [...result1, ...result2]);\n        }\n      };\n\n      thisFork(rejOnce, (...values: Array<any>) => {\n        result1 = values;\n        resolveBoth();\n      });\n\n      thatFork(rejOnce, (...values: Array<any>) => {\n        result2 = values;\n        resolveBoth();\n      });\n    });\n  }\n\n  chain(f: Function) {\n    if (!isFunction(f)) throwError(\"Task: Function required\");\n    const thisFork = this.getValue();\n\n    return new Task((rej: Function, res: Function) => {\n      thisFork(rej, (...args: Array<any>) => {\n        const t = f.call(null, args);\n        if (!t.fork)\n          throwError(\"Task: function must return another Task\");\n        t.fork(rej, res);\n      });\n    });\n  }\n\n  toPromise() {\n    const thisFork = this.getValue();\n    return new Promise((res, rej) => {\n      thisFork(rej, res);\n    });\n  }\n}\n\n// @ts-ignore: implicit any\nTask.prototype['fantasy-land/map'] = Task.prototype.map;\n// @ts-ignore: implicit any\nTask.prototype['fantasy-land/concat'] = Task.prototype.concat;\n// @ts-ignore: implicit any\nTask.prototype['fantasy-land/chain'] = Task.prototype.chain;\n// @ts-ignore: implicit any\nTask.prototype['fantasy-land/of'] = Task.prototype.of;\n// @ts-ignore: implicit any\nTask.prototype['fantasy-land/ap'] = Task.prototype.ap;\n\nexport default Task;\n","import TaskType from \"./task-type\"\n\nconst Task: any = (f: (rej: Function, res: Function) => any) => new TaskType(f);\nTask.of = TaskType.of;\nTask.rejected = TaskType.rejected;\n\nexport default Task;","import {\n  id,\n  once,\n  fmap,\n  bimap,\n  chain,\n  caseOf,\n  curry,\n  ncurry,\n  compose,\n  liftAn,\n  liftA1,\n  liftA2,\n  liftA3,\n  liftA4,\n  liftA5\n} from \"./functions/helpers\";\n\n//Algebraic Data Types\nimport Pair from \"./data-types/pair\";\nimport Either from \"./data-types/either\";\nimport Maybe from \"./data-types/maybe\";\nimport Task from \"./data-types/task\";\n\nexport default {\n  id,\n  once,\n  fmap,\n  bimap,\n  chain,\n  caseOf,\n  curry,\n  ncurry,\n  compose,\n  liftAn,\n  liftA1,\n  liftA2,\n  liftA3,\n  liftA4,\n  liftA5,\n  Pair,\n  Either,\n  Maybe,\n  Task\n};\n"],"names":["v","Right","Left","def","e","swap","f","_i","apply","args","fl","fr","bimap","isLeft","isRight","j","isFunction","getValue","throwError","caseOf","_this","map","_value","Either","prototype","equals","chain","of","ap","_super","n","o","Just","Nothing","ar","filter","m","isJust","isNothing","x","Maybe","zero","slice","Array","id","once","_called","_result","undefined","curry","fn","arity","length","call","arguments","curried","concat","ncurry","curArgs","Object","keys","diff","indexOf","ar2","assign","compose","fns","reduce","g","_fmap","fmap","_bimap","f1","f2","b","_chain","_caseOf","p","_liftAn","init","res","rest","a","ca","_liftA1","_liftA2","_liftA3","f3","_liftA4","f4","_liftA5","f5","liftAn","liftA1","liftA2","liftA3","liftA4","liftA5","v1","v2","Pair","fst","snd","lf","ls","rf","rs","l","r","PairType","Task","_","resolve","reject","fork","name","rej","t","thisFork","value","gotValues","gotFuction","rejected","rejOnce","resolveBoth","exec","values","thatFork","result1","result2","Promise","TaskType"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;mBAAA;aAaS,GAAP,UAAgBA,CAAhB;eACS,IAAIC,KAAJ,CAAUD,CAAV,CAAP;KADK;gBAIA,GAAP,UAAmBA,CAAnB;eACS,IAAIC,KAAJ,CAAUD,CAAV,CAAP;KADK;eAIA,GAAP,UAAkBA,CAAlB;eACS,IAAIE,IAAJ,CAASF,CAAT,CAAP;KADK;uBAIA,GAAP,UAA0BA,CAA1B;eACUA,IAAI,IAAIC,KAAJ,CAAUD,CAAV,CAAJ,GAAmB,IAAIE,IAAJ,CAASF,CAAT,CAA3B;KADK;sBAIA,GAAP,UAAyBG,GAAzB,EAAmCH,CAAnC;eACSA,IAAI,IAAIC,KAAJ,CAAUD,CAAV,CAAJ,GAAmB,IAAIC,KAAJ,CAAUE,GAAV,CAA1B;KADK;eAIA,GAAP,UAAiBC,CAAjB;eACSA,EAAEC,IAAF,EAAP;KADK;cAIA,GAAP,UAAWC,CAAX;eACS;yBAAM;iBAAA,YAAAC,uBAAAA;uBAAA,iBAAA;;gBACP;uBACK,IAAIN,KAAJ,CAAgBK,EAAEE,KAAF,CAAQ,IAAR,EAAcC,IAAd,CAAhB,CAAP;aADF,CAEE,OAAOL,CAAP,EAAU;uBACH,IAAIF,IAAJ,CAAeE,CAAf,CAAP;;SAJJ;KADK;gBAUA,GAAP,UAAyBA,CAAzB,EAAyCM,EAAzC,EAA0DC,EAA1D;eACSP,EAAEQ,KAAF,CAAQF,EAAR,EAAYC,EAAZ,CAAP;KADK;iBAIA,GAAP,UAAoBX,CAApB;eACSA,EAAEa,MAAF,EAAP;KADK;kBAIA,GAAP,UAAqBb,CAArB;eACSA,EAAEc,OAAF,EAAP;KADK;oBAIP,GAAA,GAAA,UAAMd,CAAN;eACS,IAAIC,KAAJ,CAAUD,CAAV,CAAP;KADF;oBAIA,GAAA,GAAA,UAAMe,CAAN;wBAAA;YACM,CAACC,WAAWD,EAAEE,QAAF,EAAX,CAAL,EACEC,WAAW,yCAAX;eAEKC,OAAO;kBACN,cAACnB,CAAD;uBAAUe,CAAA;aADJ;mBAEL,eAACf,CAAD;uBAAoBoB,MAAKC,GAAL,CAASrB,CAAT,CAAA;;SAFtB,EAGJe,CAHI,CAAP;KAJF;oBAUA,SAAA,GAAA;eACS,KAAKO,MAAZ;KADF;iBAIF;GA7EA;AA+EAC,OAAOC,SAAP,CAAiB,qBAAjB,IAA0CD,OAAOC,SAAP,CAAiBC,MAA3D;AAEAF,OAAOC,SAAP,CAAiB,kBAAjB,IAAuCD,OAAOC,SAAP,CAAiBH,GAAxD;AAEAE,OAAOC,SAAP,CAAiB,oBAAjB,IAAyCD,OAAOC,SAAP,CAAiBZ,KAA1D;AAEAW,OAAOC,SAAP,CAAiB,oBAAjB,IAAyCD,OAAOC,SAAP,CAAiBE,KAA1D;AAEAH,OAAOC,SAAP,CAAiB,iBAAjB,IAAsCD,OAAOC,SAAP,CAAiBG,EAAvD;AAEAJ,OAAOC,SAAP,CAAiB,iBAAjB,IAAsCD,OAAOC,SAAP,CAAiBI,EAAvD;AAEA;aAAyB,KAAA,QAAA;iBAEvB,CAAY5B,CAAZ;oBACE6B,WAAA,KAAA,SADF;cAEOP,MAAL,GAActB,CAAd;;;kBAGF,OAAA,GAAA,UAAO8B,CAAP;eAEIA,aAAa5B,IAAb,IACA4B,EAAEjB,MADF,IAEAiB,EAAEjB,MAAF,EAFA,IAGAiB,EAAEb,QAAF,OAAiB,KAAKA,QAAL,EAJnB;KADF;kBASA,IAAA,GAAA,UAAOX,CAAP;eACS,IAAIJ,IAAJ,CAAkB,KAAKe,QAAL,EAAlB,CAAP;KADF;kBAIA,MAAA,GAAA,UAAYP,EAAZ,EAA6BC,EAA7B;eACS,IAAIT,IAAJ,CAASQ,GAAM,KAAKO,QAAL,EAAN,CAAT,CAAP;KADF;kBAIA,MAAA,GAAA,UAASX,CAAT;eACS,IAAIJ,IAAJ,CAAiB,KAAKe,QAAL,EAAjB,CAAP;KADF;kBAIA,QAAA,GAAA;eACS,KAAP;KADF;kBAIA,OAAA,GAAA;eACS,IAAP;KADF;kBAIA,KAAA,GAAA;eACS,IAAIhB,KAAJ,CAAmB,KAAKgB,QAAL,EAAnB,CAAP;KADF;kBAIA,SAAA,GAAA;eACS,UAAQ,KAAKA,QAAL,EAAR,MAAP;KADF;kBAIA,OAAA,GAAA,UAAOc,CAAP;eACSA,EAAE7B,IAAF,GACH6B,EAAE7B,IAAF,CAAO,KAAKe,QAAL,EAAP,CADG,GAEHC,WAAW,wBAAX,CAFJ;KADF;eAKF;EAjDyBK,OAAzB;AAmDA;aAAyB,MAAA,QAAA;kBAEvB,CAAYvB,CAAZ;oBACE6B,WAAA,KAAA,SADF;cAEOP,MAAL,GAActB,CAAd;;;mBAGF,OAAA,GAAA,UAAOe,CAAP;eAEIA,aAAad,KAAb,IACAc,EAAED,OADF,IAEAC,EAAED,OAAF,EAFA,IAGAC,EAAEE,QAAF,OAAiB,KAAKA,QAAL,EAJnB;KADF;mBASA,IAAA,GAAA,UAAOX,CAAP;YACM,CAACU,WAAWV,CAAX,CAAL,EAAoBY,WAAW,6BAAX;eACb,IAAIjB,KAAJ,CAAgBK,EAAK,KAAKW,QAAL,EAAL,CAAhB,CAAP;KAFF;mBAKA,MAAA,GAAA,UAAYP,EAAZ,EAA6BC,EAA7B;eACS,IAAIV,KAAJ,CAAUU,GAAM,KAAKM,QAAL,EAAN,CAAV,CAAP;KADF;mBAIA,MAAA,GAAA,UAASX,CAAT;YACM,CAACU,WAAWV,CAAX,CAAL,EAAoBY,WAAW,6BAAX;eACbZ,EAAK,KAAKW,QAAL,EAAL,CAAP;KAFF;mBAKA,QAAA,GAAA;eACS,IAAP;KADF;mBAIA,OAAA,GAAA;eACS,KAAP;KADF;mBAIA,KAAA,GAAA;eACS,IAAIf,IAAJ,CAAkB,KAAKe,QAAL,EAAlB,CAAP;KADF;mBAIA,SAAA,GAAA;eACS,WAAS,KAAKA,QAAL,EAAT,MAAP;KADF;mBAIA,OAAA,GAAA,UAAOc,CAAP;eACSA,EAAE9B,KAAF,GACH8B,EAAE9B,KAAF,CAAQ,KAAKgB,QAAL,EAAR,CADG,GAEHC,WAAW,wBAAX,CAFJ;KADF;gBAKF;EAnDyBK,OAAzB;;AC9IA;kBAAA;YAWS,GAAP,UAAavB,CAAb;eACS,IAAIgC,IAAJ,CAAShC,CAAT,CAAP;KADK;cAIA,GAAP;eACS,IAAIiC,OAAJ,EAAP;KADK;cAIA,GAAP,UAAejC,CAAf;eACS,IAAIgC,IAAJ,CAAShC,CAAT,CAAP;KADK;iBAIA,GAAP;eACS,IAAIiC,OAAJ,EAAP;KADK;sBAIA,GAAP,UAAuBjC,CAAvB;eACUA,IAAI,IAAIgC,IAAJ,CAAShC,CAAT,CAAJ,GAAkB,IAAIiC,OAAJ,EAA1B;KADK;qBAIA,GAAP,UAAsB9B,GAAtB,EAAgCH,CAAhC;eACSA,IAAI,IAAIgC,IAAJ,CAAShC,CAAT,CAAJ,GAAkB,IAAIgC,IAAJ,CAAS7B,GAAT,CAAzB;KADK;mBAIA,GAAP,UAAoB+B,EAApB;eACSA,GAAGC,MAAH,CAAU,UAAAC,CAAA;mBAAKA,EAAEC,MAAF,EAAA;SAAf,EAA2BhB,GAA3B,CAA+B,UAAAe,CAAA;mBAAKA,EAAEnB,QAAF,EAAA;SAApC,CAAP;KADK;mBAIA,GAAP,UAAoBjB,CAApB;eACSA,EAAEsC,SAAF,EAAP;KADK;gBAIA,GAAP,UAAiBtC,CAAjB;eACSA,EAAEqC,MAAF,EAAP;KADK;mBAIP,GAAA,GAAA,UAAMrC,CAAN;eACS,IAAIgC,IAAJ,CAAShC,CAAT,CAAP;KADF;mBAIA,IAAA,GAAA,UAAOA,CAAP;wBAAA;eACSmB,OAAO;qBACH,iBAACoB,CAAD;uBAAYvC,CAAA;aADT;kBAEN,cAACuC,CAAD;uBAAYnB,KAAA;;SAFb,EAGJ,IAHI,CAAP;KADF;mBAOA,GAAA,GAAA,UAAML,CAAN;wBAAA;YACM,CAACC,WAAWD,EAAEE,QAAF,EAAX,CAAL,EACEC,WAAW,wCAAX;eAEKC,OAAO;qBACH,iBAACnB,CAAD;uBAAUe,CAAA;aADP;kBAEN,cAACf,CAAD;uBAAoBoB,MAAKC,GAAL,CAASrB,CAAT,CAAA;;SAFrB,EAGJe,CAHI,CAAP;KAJF;mBAUA,SAAA,GAAA;eACS,KAAKO,MAAZ;KADF;gBAGF;GAvEA;AAyEAkB,MAAMhB,SAAN,CAAgB,qBAAhB,IAAyCgB,MAAMhB,SAAN,CAAgBC,MAAzD;AAEAe,MAAMhB,SAAN,CAAgB,kBAAhB,IAAsCgB,MAAMhB,SAAN,CAAgBH,GAAtD;AAEAmB,MAAMhB,SAAN,CAAgB,oBAAhB,IAAwCgB,MAAMhB,SAAN,CAAgBE,KAAxD;AAEAc,MAAMhB,SAAN,CAAgB,iBAAhB,IAAqCgB,MAAMhB,SAAN,CAAgBG,EAArD;AAEAa,MAAMhB,SAAN,CAAgB,mBAAhB,IAAuCgB,MAAMhB,SAAN,CAAgBiB,IAAvD;AAEAD,MAAMhB,SAAN,CAAgB,iBAAhB,IAAqCgB,MAAMhB,SAAN,CAAgBI,EAArD;AAEA;aAAgC,QAAA,QAAA;oBAAhC;;;qBACE,OAAA,GAAA,UAAOE,CAAP;eACSA,aAAaG,OAAb,IAAwBH,EAAEQ,SAA1B,IAAuCR,EAAEQ,SAAF,EAA9C;KADF;qBAIA,IAAA,GAAA,UAAOhC,CAAP;eACS,IAAI2B,OAAJ,EAAP;KADF;qBAIA,MAAA,GAAA,UAAS3B,CAAT;eACS,IAAI2B,OAAJ,EAAP;KADF;qBAIA,OAAA,GAAA;eACS,KAAP;KADF;qBAIA,UAAA,GAAA;eACS,IAAP;KADF;qBAIA,SAAA,GAAA;eACS,WAAP;KADF;qBAIA,OAAA,GAAA,UAAOF,CAAP;eACSA,EAAEE,OAAF,GAAYF,EAAEE,OAAF,EAAZ,GAA0Bf,WAAW,0BAAX,CAAjC;KADF;kBAGF;EA5BgCsB,MAAhC;AA8BA;aAA6B,KAAA,QAAA;iBAC3B,CAAYxC,CAAZ;oBACE6B,WAAA,KAAA,SADF;cAEOP,MAAL,GAActB,CAAd;;;kBAGF,OAAA,GAAA,UAAOe,CAAP;eAEIA,aAAaiB,IAAb,IACAjB,EAAEsB,MADF,IAEAtB,EAAEsB,MAAF,EAFA,IAGAtB,EAAEE,QAAF,OAAiB,KAAKA,QAAL,EAJnB;KADF;kBASA,IAAA,GAAA,UAAOX,CAAP;YACM,CAACU,WAAWV,CAAX,CAAL,EAAoBY,WAAW,4BAAX;eACb,IAAIc,IAAJ,CAAS1B,EAAE,KAAKW,QAAL,EAAF,CAAT,CAAP;KAFF;kBAKA,MAAA,GAAA,UAASX,CAAT;YACM,CAACU,WAAWV,CAAX,CAAL,EAAoBY,WAAW,4BAAX;eACbZ,EAAE,KAAKW,QAAL,EAAF,CAAP;KAFF;kBAKA,OAAA,GAAA;eACS,IAAP;KADF;kBAIA,UAAA,GAAA;eACS,KAAP;KADF;kBAIA,SAAA,GAAA;eACS,UAAQ,KAAKA,QAAL,EAAR,MAAP;KADF;kBAIA,OAAA,GAAA,UAAOc,CAAP;eACSA,EAAEC,IAAF,GACHD,EAAEC,IAAF,CAAO,KAAKf,QAAL,EAAP,CADG,GAEHC,WAAW,sBAAX,CAFJ;KADF;eAKF;EA1C6BsB,MAA7B;;AClHA,IAAME,QAAQC,MAAMnB,SAAN,CAAgBkB,KAA9B;AAMA,IAAMxB,aAAa,SAAbA,UAAa,CAACqB,CAAD;UACXA,CAAN;CADF;AAQA,IAAMK,KAAK,SAALA,EAAK,CAACL,CAAD;WAAiBA,CAAA;CAA5B;AAMA,IAAMvB,aAAa,SAAbA,UAAa,CAACV,CAAD;WAAY,OAAOA,CAAP,KAAa,UAAb;CAA/B;AAMA,IAAMuC,OAAO,SAAPA,IAAO,CAACvC,CAAD;QACP,CAACU,WAAWV,CAAX,CAAL,EAAoBY,WAAW,uBAAX;QAChB4B,UAAU,KAAd;QACIC,UAAeC,SAAnB;WAEO;qBAAC;aAAA,YAAAzC,uBAAAA;mBAAA,iBAAA;;YACF,CAACuC,OAAL,EAAc;sBACF,IAAV;sBACUxC,EAAEE,KAAF,CAAQ,IAAR,EAAcC,IAAd,CAAV;;eAEKsC,OAAP;KALF;CALF;AAkBA,IAAME,QAAQ,SAARA,KAAQ,CAACC,EAAD;QACR,CAAClC,WAAWkC,EAAX,CAAL,EAAqBhC,WAAW,uBAAX;QAEfiC,QAAQD,GAAGE,MAAjB;WACO,gBAAA;YACD3C,OAAOiC,MAAMW,IAAN,CAAWC,SAAX,EAAsB,CAAtB,CAAX;YACI7C,KAAK2C,MAAL,IAAeD,KAAnB,EAA0B,OAAOD,GAAG1C,KAAH,CAAS,IAAT,EAAeC,IAAf,CAAP;eAEnB;mBACE8C,QAAQ/C,KAAR,CAAc,IAAd,EAAoBC,KAAK+C,MAAL,CAAYd,MAAMW,IAAN,CAAWC,SAAX,CAAZ,CAApB,CAAP;SADF;KAJF;CAJF;AAmBA,IAAMG,SAAS,SAATA,MAAS,CAACP,EAAD,EAAezC,IAAf;QACT,CAACO,WAAWkC,EAAX,CAAL,EAAqBhC,WAAW,uBAAX;QACjBgC,GAAGE,MAAH,GAAY,CAAhB,EAAmBlC,WAAW,yCAAX;WAIZ,gBAAA,CAAiBgB,EAAjB;YACCwB,UAAUC,OAAOC,IAAP,CAAY1B,EAAZ,CAAhB;YACM2B,OAAOpD,KAAK0B,MAAL,CAAY,UAAAI,CAAA;mBAAKmB,QAAQI,OAAR,CAAgBvB,CAAhB,IAAqB,CAArB;SAAjB,CAAb;YACIsB,KAAKT,MAAL,GAAc,CAAlB,EACE,OAAO,UAACW,GAAD;mBACLR,QAAQF,IAAR,CAAa,IAAb,EAAyBM,OAAQK,MAAR,CAAe,EAAf,EAAmB9B,EAAnB,EAAuB6B,GAAvB,CAAzB,CAAA;SADF;eAEKb,GAAGG,IAAH,CAAQ,IAAR,EAAcnB,EAAd,CAAP;KANF;CANF;AAqBA,IAAM+B,UAAU,SAAVA,OAAU;gBAAC;SAAA,YAAA1D,uBAAAA;cAAA,iBAAA;;QACX2D,IAAId,MAAJ,IAAc,CAAlB,EAAqBlC,WAAW,qBAAX;WACdgD,IAAIC,MAAJ,CAAW,UAAC7D,CAAD,EAAI8D,CAAJ;eAAU;yBAAC;iBAAA,YAAA7D,uBAAAA;uBAAA,iBAAA;;mBAAwBD,EAAE8D,OAAA,OAAA,EAAK3D,IAAL,CAAF,CAAA;SAAzB;KAArB,CAAP;CAFF;AAWA,IAAM4D,QAAQ,SAARA,KAAQ,CAACnB,EAAD,EAAe5C,CAAf;QACR,CAACU,WAAWkC,EAAX,CAAL,EAAqBhC,WAAW,uBAAX;QACjB,CAACZ,EAAEe,GAAP,EAAYH,WAAW,mBAAX;WACLZ,EAAEe,GAAF,CAAMgC,IAAN,CAAW/C,CAAX,EAAc4C,EAAd,CAAP;CAHF;AAKA,IAAMoB,OAAOrB,MAAMoB,KAAN,CAAb;AASA,IAAME,SAAS,SAATA,MAAS,CAACC,EAAD,EAAeC,EAAf,EAA6BC,CAA7B;QACT,CAAC1D,WAAWwD,EAAX,CAAD,IAAmB,CAACxD,WAAWyD,EAAX,CAAxB,EAAwCvD,WAAW,wBAAX;QACpC,CAACwD,EAAE9D,KAAP,EAAcM,WAAW,qBAAX;WACPwD,EAAE9D,KAAF,CAAQ4D,EAAR,EAAYC,EAAZ,CAAP;CAHF;AAKA,IAAM7D,QAAQqC,MAAMsB,MAAN,CAAd;AAQA,IAAMI,SAAS,SAATA,MAAS,CAACrE,CAAD,EAAc8B,CAAd;QACT,CAACA,EAAEV,KAAP,EAAcR,WAAW,uBAAX;QACV,CAACF,WAAWV,CAAX,CAAL,EAAoBY,WAAW,uBAAX;WACbkB,EAAEV,KAAF,CAAQ2B,IAAR,CAAajB,CAAb,EAAgB9B,CAAhB,CAAP;CAHF;AAKA,IAAMoB,QAAQuB,MAAM0B,MAAN,CAAd;AAQA,IAAMC,UAAU,SAAVA,OAAU,CAAC7C,CAAD,EAAY8C,CAAZ;WACd,CAACA,EAAE1D,MAAH,GAAYD,WAAW,0BAAX,CAAZ,GAAqD2D,EAAE1D,MAAF,CAASY,CAAT,CAArD;CADF;AAEA,IAAMZ,SAAS8B,MAAM2B,OAAN,CAAf;AAGA,IAAME,UAAU,SAAVA,OAAU,CAACxE,CAAD,EAAc4C,EAAd;QACV,CAAClC,WAAWV,CAAX,CAAL,EAAoBY,WAAW,oBAAX;QAChBgC,GAAGE,MAAH,IAAa,CAAjB,EAAoBlC,WAAW,iBAAX;QACd6D,OAAc7B,GAAG,CAAH,EAAM7B,GAAN,CAAUf,CAAV,CAApB;QACI0E,MAAMD,IAAV;QACI7B,GAAGE,MAAH,GAAY,CAAhB,EAAmB;YACX6B,OAAO/B,GAAGR,KAAH,CAAS,CAAT,CAAb;cACMuC,KAAKd,MAAL,CAAY,UAACe,CAAD,EAAWC,EAAX;mBAAyBA,GAAGvD,EAAH,CAAMsD,CAAN,CAAA;SAArC,EAA+CH,IAA/C,CAAN;;WAEKC,GAAP;CATF;AAWA,IAAMI,UAAU,SAAVA,OAAU,CAAC9E,CAAD,EAAckE,EAAd;WAA4BM,QAAQxE,CAAR,EAAW,CAACkE,EAAD,CAAX,CAAA;CAA5C;AACA,IAAMa,UAAU,SAAVA,OAAU,CAAC/E,CAAD,EAAckE,EAAd,EAAyBC,EAAzB;WAAuCK,QAAQxE,CAAR,EAAW,CAACkE,EAAD,EAAKC,EAAL,CAAX,CAAA;CAAvD;AACA,IAAMa,UAAU,SAAVA,OAAU,CAAChF,CAAD,EAAckE,EAAd,EAAyBC,EAAzB,EAAoCc,EAApC;WACdT,QAAQxE,CAAR,EAAW,CAACkE,EAAD,EAAKC,EAAL,EAASc,EAAT,CAAX,CAAA;CADF;AAEA,IAAMC,UAAU,SAAVA,OAAU,CAAClF,CAAD,EAAckE,EAAd,EAAyBC,EAAzB,EAAoCc,EAApC,EAA+CE,EAA/C;WACdX,QAAQxE,CAAR,EAAW,CAACkE,EAAD,EAAKC,EAAL,EAASc,EAAT,EAAaE,EAAb,CAAX,CAAA;CADF;AAEA,IAAMC,UAAU,SAAVA,OAAU,CACdpF,CADc,EAEdkE,EAFc,EAGdC,EAHc,EAIdc,EAJc,EAKdE,EALc,EAMdE,EANc;WAOXb,QAAQxE,CAAR,EAAW,CAACkE,EAAD,EAAKC,EAAL,EAASc,EAAT,EAAaE,EAAb,EAAiBE,EAAjB,CAAX,CAAA;CAPL;AAcA,IAAMC,SAAS3C,MAAM6B,OAAN,CAAf;AAOA,IAAMe,SAAS5C,MAAMmC,OAAN,CAAf;AAQA,IAAMU,SAAS7C,MAAMoC,OAAN,CAAf;AASA,IAAMU,SAAS9C,MAAMqC,OAAN,CAAf;AAUA,IAAMU,SAAS/C,MAAMuC,OAAN,CAAf;AAWA,IAAMS,SAAShD,MAAMyC,OAAN,CAAf;;ACzNA;iBAIE,CAAYQ,EAAZ,EAAmBC,EAAnB;YACMD,OAAOlD,SAAP,IAAoBmD,OAAOnD,SAA/B,EACE9B,WAAW,oDAAX;aAEGI,MAAL,GAAc,CAAC4E,EAAD,EAAKC,EAAL,CAAd;;WAGK,GAAP,UAAanG,CAAb;eACS,IAAIoG,IAAJ,CAASpG,CAAT,EAAYA,CAAZ,CAAP;KADK;kBAIP,GAAA,GAAA,UAAMA,CAAN;eACS,IAAIoG,IAAJ,CAASpG,CAAT,EAAYA,CAAZ,CAAP;KADF;kBAIA,OAAA,GAAA,UAAOe,CAAP;eACYA,EAAEsF,GAAF,OAAe,KAAKA,GAAL,EAAf,IAAgCtF,EAAEuF,GAAF,OAAe,KAAKA,GAAL,EAAzD;KADF;kBAIA,OAAA,GAAA,UAAOzB,CAAP;YACM,EAAEA,aAAauB,IAAf,CAAJ,EAA0BlF,WAAW,qBAAX;YACpBqF,KAAU,KAAKF,GAAL,EAAhB;YACMG,KAAU,KAAKF,GAAL,EAAhB;YACMG,KAAK5B,EAAEwB,GAAF,EAAX;YACMK,KAAK7B,EAAEyB,GAAF,EAAX;YAEI,CAACC,GAAG/C,MAAJ,IAAc,CAACgD,GAAGhD,MAAlB,IAA4B,CAACiD,GAAGjD,MAAhC,IAA0C,CAACkD,GAAGlD,MAAlD,EACEtC,WAAW,0CAAX;eAEK,IAAIkF,IAAJ,CAASG,GAAG/C,MAAH,CAAUiD,EAAV,CAAT,EAAwBD,GAAGhD,MAAH,CAAUkD,EAAV,CAAxB,CAAP;KAVF;kBAaA,IAAA,GAAA;eACY,KAAKzF,QAAL,GAAgB,CAAhB,CAAV;KADF;kBAIA,IAAA,GAAA;eACY,KAAKA,QAAL,GAAgB,CAAhB,CAAV;KADF;kBAIA,GAAA,GAAA,UAASF,CAAT;YACM,EAAEA,aAAaqF,IAAf,CAAJ,EAA0BlF,WAAW,qBAAX;YACpBgC,KAAUnC,EAAEuF,GAAF,EAAhB;YACI,CAACtF,WAAWkC,EAAX,CAAL,EACEhC,WAAW,iDAAX;YACIyF,IAAS,KAAKN,GAAL,EAAf;YACMO,IAAS7F,EAAEsF,GAAF,EAAf;YAEI,CAACM,EAAEnD,MAAH,IAAa,CAACoD,EAAEpD,MAApB,EAA4BtC,WAAW,kCAAX;eAErB,IAAIkF,IAAJ,CAASO,EAAEnD,MAAF,CAASoD,CAAT,CAAT,EAAsB1D,GAAG,KAAKoD,GAAL,EAAH,CAAtB,CAAP;KAVF;kBAaA,SAAA,GAAA;eACS,KAAKhF,MAAZ;KADF;kBAIA,IAAA,GAAA,UAAOhB,CAAP;YACM,CAACU,WAAWV,CAAX,CAAL,EAAoBY,WAAW,2BAAX;eACb,IAAIkF,IAAJ,CAAY,KAAKC,GAAL,EAAZ,EAAwB/F,EAAK,KAAKgG,GAAL,EAAL,CAAxB,CAAP;KAFF;kBAKA,MAAA,GAAA,UAAY9B,EAAZ,EAA6BC,EAA7B;YACM,CAACzD,WAAWwD,EAAX,CAAD,IAAmB,CAACxD,WAAWyD,EAAX,CAAxB,EACEvD,WAAW,yCAAX;eACK,IAAIkF,IAAJ,CAAS5B,GAAM,KAAK6B,GAAL,EAAN,CAAT,EAA4B5B,GAAM,KAAK6B,GAAL,EAAN,CAA5B,CAAP;KAHF;kBAMA,MAAA,GAAA,UAAYhG,CAAZ;YACM,CAACU,WAAWV,CAAX,CAAL,EAAoBY,WAAW,2BAAX;YACdyF,IAAS,KAAKN,GAAL,EAAf;YACI,CAACM,EAAEnD,MAAP,EAAetC,WAAW,yCAAX;YACT2D,IAAIvE,EAAK,KAAKgG,GAAL,EAAL,CAAV;YACI,EAAEzB,aAAauB,IAAf,CAAJ,EAA0BlF,WAAW,mCAAX;YACpB0F,IAAS/B,EAAEwB,GAAF,EAAf;YACI,CAACO,EAAEpD,MAAP,EACEtC,WACE,8DADF;eAIK,IAAIkF,IAAJ,CAAYO,EAAEnD,MAAF,CAASoD,CAAT,CAAZ,EAA4B/B,EAAEyB,GAAF,EAA5B,CAAP;KAZF;kBAeA,KAAA,GAAA;YACQtG,IAAI,KAAKiB,QAAL,EAAV;eACO,IAAImF,IAAJ,CAASpG,EAAE,CAAF,CAAT,EAAeA,EAAE,CAAF,CAAf,CAAP;KAFF;kBAKA,SAAA,GAAA;YACQA,IAAI,KAAKiB,QAAL,EAAV;eACO,WAASjB,EAAE,CAAF,CAAT,SAAA,GAAoBA,EAAE,CAAF,CAApB,OAAP;KAFF;eAIF;GAhGA;AAmGAoG,OAAK5E,SAAL,CAAe,qBAAf,IAAwC4E,OAAK5E,SAAL,CAAeC,MAAvD;AAEA2E,OAAK5E,SAAL,CAAe,kBAAf,IAAqC4E,OAAK5E,SAAL,CAAeH,GAApD;AAEA+E,OAAK5E,SAAL,CAAe,qBAAf,IAAwC4E,OAAK5E,SAAL,CAAegC,MAAvD;AAEA4C,OAAK5E,SAAL,CAAe,oBAAf,IAAuC4E,OAAK5E,SAAL,CAAeZ,KAAtD;AAEAwF,OAAK5E,SAAL,CAAe,oBAAf,IAAuC4E,OAAK5E,SAAL,CAAeE,KAAtD;AAEA0E,OAAK5E,SAAL,CAAe,iBAAf,IAAoC4E,OAAK5E,SAAL,CAAeG,EAAnD;AAEAyE,OAAK5E,SAAL,CAAe,iBAAf,IAAoC4E,OAAK5E,SAAL,CAAeI,EAAnD;;AChHA,IAAMwE,OAAY,SAAZA,IAAY,CAACF,EAAD,EAAUC,EAAV;SAAsB,IAAIU,MAAJ,CAAaX,EAAb,EAAiBC,EAAjB,CAAA;CAAxC;AACAC,KAAKzE,EAAL,GAAUkF,OAASrF,SAAT,CAAmBG,EAA7B;AAEAyE,KAAK5E,SAAL,CAAe,iBAAf,IAAoCqF,OAASrF,SAAT,CAAmBG,EAAvD;;ACFA;iBAIE,CAAYrB,CAAZ;mBACaA,CAAX,IACI,KAAKgB,MAAL,GAAchB,CADlB,GAEIY,WAAW,2BAAX,CAFJ;;WAKK,GAAP,UAAUlB,CAAV;eACS,IAAI8G,IAAJ,CAAS,UAACC,CAAD,EAAcC,OAAd;mBAAoCA,QAAQhH,CAAR,CAAA;SAA7C,CAAP;KADK;iBAIA,GAAP,UAAgBA,CAAhB;eACS,IAAI8G,IAAJ,CAAS,UAACG,MAAD,EAAmBF,CAAnB;mBAAmCE,OAAOjH,CAAP,CAAA;SAA5C,CAAP;KADK;kBAIP,GAAA,GAAA,UAAGA,CAAH;eACS,IAAI8G,IAAJ,CAAS,UAACC,CAAD,EAAcC,OAAd;mBAAoCA,QAAQhH,CAAR,CAAA;SAA7C,CAAP;KADF;kBAIA,SAAA,GAAA,UAASA,CAAT;eACS,IAAI8G,IAAJ,CAAS,UAACG,MAAD,EAAmBF,CAAnB;mBAAmCE,OAAOjH,CAAP,CAAA;SAA5C,CAAP;KADF;kBAIA,KAAA,GAAA,UAAKiH,MAAL,EAAuBD,OAAvB;YACM,CAAChG,WAAWgG,OAAX,CAAD,IAAwB,CAAChG,WAAWiG,MAAX,CAA7B,EACE/F,WAAW,+CAAX;YACIgC,KAAK,KAAKjC,QAAL,EAAX;WACGgG,MAAH,EAAWD,OAAX;KAJF;kBAOA,SAAA,GAAA;YACQE,OAAO,KAAKjG,QAAL,EAAb;eACO,UAAQiG,KAAKC,IAAb,MAAP;KAFF;kBAKA,IAAA,GAAA,UAAS7G,CAAT;YACM,CAACU,WAAWV,CAAX,CAAL,EAAoBY,WAAW,2BAAX;YACdgG,OAAO,KAAKjG,QAAL,EAAb;eACO,IAAI6F,IAAJ,CAAS,UAACM,GAAD,EAAgBpC,GAAhB;mBACdkC,KAAKE,GAAL,EAAUnD,QAAQe,GAAR,EAAa1E,CAAb,CAAV,CAAA;SADK,CAAP;KAHF;kBAQA,SAAA,GAAA;eACS,KAAKgB,MAAZ;KADF;kBAIA,GAAA,GAAA,UAAG+F,CAAH;YACM,EAAEA,aAAaP,IAAf,CAAJ,EAA0B5F,WAAW,qBAAX;YACpBoG,WAAW,KAAKrG,QAAL,EAAjB;YACIsG,KAAJ;YACIrE,EAAJ;YACIsE,YAAqB,KAAzB;YACIC,aAAsB,KAA1B;YACIC,WAAoB,KAAxB;eAEO,IAAIZ,IAAJ,CAAS,UAACM,GAAD,EAAgBpC,GAAhB;gBACR2C,UAAU1D,QAAQ;2BACX,IAAX;aADc,EAEbpB,KAAKuE,GAAL,CAFa,CAAhB;gBAIMQ,cAAc,SAAdA,WAAc;oBACdJ,aAAaC,UAAb,IAA2B,CAACC,QAAhC,EAA0C;wBAClCG,OAAO5D,QAAQe,GAAR,EAAa9B,EAAb,CAAb;yBACK1C,KAAL,CAAW,IAAX,EAAiB+G,KAAjB;;aAHJ;qBAOSI,OAAT,EAAkB;+BAAC;qBAAA,YAAApH,uBAAAA;6BAAA,iBAAA;;wBACTuH,MAAR;4BACY,IAAZ;;aAFF;cAMEZ,IAAF,CAAOS,OAAP,EAAgB,UAACrH,CAAD;oBACV,CAACU,WAAWV,CAAX,CAAL,EACEY,WAAW,0CAAX;qBACGZ,CAAL;6BACa,IAAb;;aAJF;SAlBK,CAAP;KATF;kBAqCA,OAAA,GAAA,UAAO+G,CAAP;YACM,EAAEA,aAAaP,IAAf,CAAJ,EAA0B5F,WAAW,qBAAX;YACpBoG,WAAW,KAAKrG,QAAL,EAAjB;YACM8G,WAAWV,EAAEpG,QAAF,EAAjB;eAEO,IAAI6F,IAAJ,CAAS,UAACM,GAAD,EAAgBpC,GAAhB;gBACV0C,WAAoB,KAAxB;gBACMC,UAAU1D,QAAQ;2BACX,IAAX;aADc,EAEbpB,KAAKuE,GAAL,CAFa,CAAhB;gBAGIY,OAAJ;gBACIC,OAAJ;gBAEML,cAAc,SAAdA,WAAc;oBACdI,WAAWC,OAAX,IAAsB,CAACP,QAA3B,EAAqC;wBAC/BlH,KAAJ,CAAU,IAAV,EAAoBwH,cAAA,CAAYC,OAAZ,CAApB;;aAFJ;qBAMSN,OAAT,EAAkB;+BAAC;qBAAA,YAAApH,uBAAAA;6BAAA,iBAAA;;0BACPuH,MAAV;;aADF;qBAKSH,OAAT,EAAkB;+BAAC;qBAAA,YAAApH,uBAAAA;6BAAA,iBAAA;;0BACPuH,MAAV;;aADF;SAnBK,CAAP;KALF;kBA+BA,MAAA,GAAA,UAAMxH,CAAN;YACM,CAACU,WAAWV,CAAX,CAAL,EAAoBY,WAAW,yBAAX;YACdoG,WAAW,KAAKrG,QAAL,EAAjB;eAEO,IAAI6F,IAAJ,CAAS,UAACM,GAAD,EAAgBpC,GAAhB;qBACLoC,GAAT,EAAc;6BAAC;qBAAA,YAAA7G,uBAAAA;2BAAA,iBAAA;;oBACP8G,IAAI/G,EAAE+C,IAAF,CAAO,IAAP,EAAa5C,IAAb,CAAV;oBACI,CAAC4G,EAAEH,IAAP,EACEhG,WAAW,yCAAX;kBACAgG,IAAF,CAAOE,GAAP,EAAYpC,GAAZ;aAJF;SADK,CAAP;KAJF;kBAcA,UAAA,GAAA;YACQsC,WAAW,KAAKrG,QAAL,EAAjB;eACO,IAAIiH,OAAJ,CAAY,UAAClD,GAAD,EAAMoC,GAAN;qBACRA,GAAT,EAAcpC,GAAd;SADK,CAAP;KAFF;eAMF;GA1IA;AA6IA8B,OAAKtF,SAAL,CAAe,kBAAf,IAAqCsF,OAAKtF,SAAL,CAAeH,GAApD;AAEAyF,OAAKtF,SAAL,CAAe,qBAAf,IAAwCsF,OAAKtF,SAAL,CAAegC,MAAvD;AAEAsD,OAAKtF,SAAL,CAAe,oBAAf,IAAuCsF,OAAKtF,SAAL,CAAeE,KAAtD;AAEAoF,OAAKtF,SAAL,CAAe,iBAAf,IAAoCsF,OAAKtF,SAAL,CAAeG,EAAnD;AAEAmF,OAAKtF,SAAL,CAAe,iBAAf,IAAoCsF,OAAKtF,SAAL,CAAeI,EAAnD;;ACtJA,IAAMkF,OAAY,SAAZA,IAAY,CAACxG,CAAD;SAA8C,IAAI6H,MAAJ,CAAa7H,CAAb,CAAA;CAAhE;AACAwG,KAAKnF,EAAL,GAAUwG,OAASxG,EAAnB;AACAmF,KAAKY,QAAL,GAAgBS,OAAST,QAAzB;;ACoBA,YAAe;UAAA;cAAA;cAAA;gBAAA;gBAAA;kBAAA;gBAAA;kBAAA;oBAAA;kBAAA;kBAAA;kBAAA;kBAAA;kBAAA;kBAAA;cAAA;kBAAA;gBAAA;;CAAf;;;;;;;;"}