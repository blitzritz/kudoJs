{"version":3,"file":"kudo.js","sources":["../src/functions/helpers.ts","../src/data-types/pair-type.ts","../src/data-types/pair.ts","../src/data-types/either.ts","../src/data-types/maybe.ts","../src/data-types/task-type.ts","../src/data-types/task.ts","../src/index.ts"],"sourcesContent":["import { Functor, Monad, Apply, BiFunctor, PatternMatch } from \"../interfaces\";\n\nconst slice = Array.prototype.slice;\n\n/** @function throwError\n * @param {string} x - Error message\n * @description Throw an error\n */\nconst throwError = (x: String) => {\n  throw x;\n};\n\n/** @function id\n * @param {*} x - Any\n * @description Identity Function\n */\nconst id = (x: any): any => x;\n\n/** @function isFunction\n * @param {*} f - Any\n * @description Check if supplied argument is\n */\nconst isFunction = (f: any) => typeof f === \"function\";\n\n/** @function once\n * @param {Function} f - Function to be called once\n * @description Create a function which calls the given function only once\n */\nconst once = (f: Function) => {\n  if (!isFunction(f)) throwError(\"Function not provided\");\n  let _called = false;\n  let _result: any = undefined;\n\n  return (...args: Array<any>) => {\n    if (!_called) {\n      _called = true;\n      _result = f.apply(null, args);\n    }\n    return _result;\n  };\n};\n\n/** @function curry\n * @param {Function} f - Function to be curried\n * @description Returns a curried equivalent of the provided function.\n */\nconst curry = (fn: Function): Function => {\n  if (!isFunction(fn)) throwError(\"Function not provided\");\n\n  const arity = fn.length;\n  return function curried() {\n    let args = slice.call(arguments, 0);\n    if (args.length >= arity) return fn.apply(null, args);\n\n    return function() {\n      return curried.apply(null, args.concat(slice.call(arguments)));\n    };\n  };\n};\n\n/** @function ncurry\n * @param {Function} fn - Function to be curried which accepts a single named argument object\n * @param {Array<string>} args - key names of the Function argument object\n * @description Returns a curried equivalent of the provided function which will accept named arguments in any order\n */\nconst ncurry = (fn: Function, args: Array<string>): Function => {\n  if (!isFunction(fn)) throwError(\"Function not provided\");\n  if (fn.length > 1) throwError(\"Function Arity cannot be greater than 1\");\n  //if (typeof fn.arguments[0] !== \"object\") return throwError(\"Function argument must be an object type\");\n  //const args = Object.keys(fn.arguments[0]);\n\n  return function curried(ar: Object): Function {\n    const curArgs = Object.keys(ar);\n    const diff = args.filter(x => curArgs.indexOf(x) < 0);\n    if (diff.length > 0)\n      return (ar2: Object): Function =>\n        curried.call(null, (<any>Object).assign({}, ar, ar2));\n    return fn.call(null, ar);\n  };\n};\n\n/** @function compose\n * @param {...Function} fns - functions to compose\n * @description Performs right-to-left function composition.\n * @summary compose :: Function\n */\nconst compose = (...fns: Array<Function>): Function => {\n  if (fns.length <= 0) throwError(\"Nothing to compose!\");\n  return fns.reduce((f, g) => (...args: Array<any>) => f(g(...args)));\n};\n\n/** @function fmap\n * @param {Function} fn - functions to be mapped\n * @param {Functor} f - Functor\n * @description Takes a function and a functor, applies the function to each of the functor's values, and returns a functor\n * @summary fmap :: Functor f => (a → b) → f a → f b\n */\nconst _fmap = (fn: Function, f: Functor): Functor => {\n  if (!isFunction(fn)) throwError(\"function not provided\");\n  if (!f.map) throwError(\"Functor not found\");\n  return f.map.call(f, fn);\n};\nconst fmap = curry(_fmap);\n\n/** @function bimap\n * @param {Function} f1 - function to be mapped on left\n * @param {Function} f2 - function to be mapped on right\n * @param {BiFunctor} b - BiFunctor\n * @description Apply the first argument function to the left and the second argument function to a right of Bifunctor.\n * @summary bimap :: BiFunctor b => b a c ~> (a -> e) -> (c -> d) ->  b a c -> b e d\n */\nconst _bimap = (f1: Function, f2: Function, b: BiFunctor): BiFunctor => {\n  if (!isFunction(f1) || !isFunction(f2)) throwError(\"Functions not provided\");\n  if (!b.bimap) throwError(\"BiFunctor not found\");\n  return b.bimap(f1, f2);\n};\nconst bimap = curry(_bimap);\n\n/** @function chain\n * @param {Function} fn - function that returns a monad\n * @param {Monad} m - Functor\n * @description Chain together in many computations\n * @summary chain :: Monad m => (a -> m b) -> m a -> m b\n */\nconst _chain = (f: Function, m: Monad): Monad => {\n  if (!m.chain) throwError(\"chain not implemented\");\n  if (!isFunction(f)) throwError(\"function not provided\");\n  return m.chain.call(m, f);\n};\nconst chain = curry(_chain);\n\n/** @function caseOf\n * @param {Object} o - Pattern match id as Key and function as value\n * @param {PatternMatch} p - Pattern Match Object\n * @description match an expression to a pattern. When a match is found, it evaluates the expression and returns whatever value is produced.\n * @summary caseOf :: Object -> patternMatch -> a\n */\nconst _caseOf = (o: Object, p: PatternMatch): any =>\n  !p.caseOf ? throwError(\"caseOf not implemented\") : p.caseOf(o);\nconst caseOf = curry(_caseOf);\n\nconst _liftAn = (f: Function, fn: Array<Apply>) => {\n  if (!isFunction(f)) throwError(\"Function not found\");\n  if (fn.length <= 0) throwError(\"No Apply found!\");\n  const init: Apply = fn[0].map(f);\n  let res = init;\n  if (fn.length > 1) {\n    const rest = fn.slice(1);\n    res = rest.reduce((a: Apply, ca: Apply) => ca.ap(a), init);\n  }\n  return res;\n};\nconst _liftA1 = (f: Function, f1: Apply) => _liftAn(f, [f1]);\nconst _liftA2 = (f: Function, f1: Apply, f2: Apply) => _liftAn(f, [f1, f2]);\nconst _liftA3 = (f: Function, f1: Apply, f2: Apply, f3: Apply) =>\n  _liftAn(f, [f1, f2, f3]);\nconst _liftA4 = (f: Function, f1: Apply, f2: Apply, f3: Apply, f4: Apply) =>\n  _liftAn(f, [f1, f2, f3, f4]);\nconst _liftA5 = (\n  f: Function,\n  f1: Apply,\n  f2: Apply,\n  f3: Apply,\n  f4: Apply,\n  f5: Apply\n) => _liftAn(f, [f1, f2, f3, f4, f5]);\n\n/** @function liftAn\n * @param {Function} f - Function to be lifted\n * @param {...Apply} fn - Applys to the function\n * @description lets us combine n separate wrapped values into one with a given function.\n */\nconst liftAn = curry(_liftAn);\n\n/** @function liftA1\n * @param {Function} f - Function to be lifted\n * @param {Apply} fn - 'Apply' to the function\n * @description Aka fmap\n */\nconst liftA1 = curry(_liftA1);\n\n/** @function liftA2\n * @param {Function} f - Function to be lifted\n * @param {Apply} f1 - 'Apply' to the function\n * @param {Apply} f2 - 'Apply' to the function\n * @description lets us combine 2 separate wrapped values into one with a given function.\n */\nconst liftA2 = curry(_liftA2);\n\n/** @function liftA3\n * @param {Function} f - Function to be lifted\n * @param {Apply} f1 - 'Apply' to the function\n * @param {Apply} f2 - 'Apply' to the function\n * @param {Apply} f3 - 'Apply' to the function\n * @description lets us combine 3 separate wrapped values into one with a given function.\n */\nconst liftA3 = curry(_liftA3);\n\n/** @function liftA4\n * @param {Function} f - Function to be lifted\n * @param {Apply} f1 - 'Apply' to the function\n * @param {Apply} f2 - 'Apply' to the function\n * @param {Apply} f3 - 'Apply' to the function\n * @param {Apply} f4 - 'Apply' to the function\n * @description lets us combine 4 separate wrapped values into one with a given function.\n */\nconst liftA4 = curry(_liftA4);\n\n/** @function liftA2\n * @param {Function} f - Function to be lifted\n * @param {Apply} f1 - 'Apply' to the function\n * @param {Apply} f2 - 'Apply' to the function\n * @param {Apply} f3 - 'Apply' to the function\n * @param {Apply} f4 - 'Apply' to the function\n * @param {Apply} f5 - 'Apply' to the function\n * @description lets us combine 2 separate wrapped values into one with a given function.\n */\nconst liftA5 = curry(_liftA5);\n\nexport {\n  id,\n  isFunction,\n  throwError,\n  once,\n  fmap,\n  bimap,\n  chain,\n  caseOf,\n  curry,\n  ncurry,\n  compose,\n  liftAn,\n  liftA1,\n  liftA2,\n  liftA3,\n  liftA4,\n  liftA5\n};\n","import { Setoid, Semigroup, BiFunctor, Monad } from \"../interfaces\";\nimport { throwError, isFunction } from \"../functions/helpers\";\n\nconst _of = (v: any) => {\n  return new Pair(v, v);\n};\n\nconst _pairs = new WeakMap();\nclass Pair implements Setoid, Semigroup, BiFunctor, Monad {\n  constructor(v1: any, v2: any) {\n    if (v1 === undefined || v2 === undefined)\n      throwError(\"Pair: Both first and second values must be defined\");\n    _pairs.set(this, [v1, v2]);\n  }\n\n  equals(j: Pair) {\n    return j.fst() === this.fst() && j.snd() === this.snd();\n  }\n\n  // isEqual(n: any){\n  //     return this.equals(n);\n  // }\n\n  concat(p: Pair) {\n    if (!(p instanceof Pair)) throwError(\"Pair: Pair required\");\n    const lf = this.fst();\n    const ls = this.snd();\n    const rf = p.fst();\n    const rs = p.snd();\n\n    if (!lf.concat || !ls.concat || !rf.concat || !rs.concat)\n      throwError(\"Pair: Both Pairs must contain Semigroups\");\n\n    return new Pair(lf.concat(rf), ls.concat(rs));\n  }\n\n  of(v: any) {\n    return _of(v);\n  }\n\n  fst() {\n    return this.getValue()[0];\n  }\n\n  snd() {\n    return this.getValue()[1];\n  }\n\n  ap(j: Pair): Pair {\n    if (!(j instanceof Pair)) throwError(\"Pair: Pair required\");\n    const fn = j.snd();\n    if (!isFunction(fn))\n      throwError(\"Pair: Second wrapped value should be a function\");\n    const l = this.fst();\n    const r = j.fst();\n    //console.log(l, r, fn);\n    if (!l.concat || !r.concat) throwError(\"Pair: Types should be Semigroups\");\n\n    return new Pair(l.concat(r), fn(this.snd()));\n  }\n\n  getValue() {\n    return _pairs.get(this);\n  }\n\n  map(f: Function) {\n    if (!isFunction(f)) throwError(\"Pair: Expected a function\");\n    return new Pair(this.fst(), f(this.snd()));\n  }\n\n  bimap(f1: Function, f2: Function) {\n    if (!isFunction(f1) || !isFunction(f2))\n      throwError(\"Pair: Expected functions for both parts\");\n    return new Pair(f1(this.fst()), f2(this.snd()));\n  }\n\n  chain(f: Function) {\n    if (!isFunction(f)) throwError(\"Pair: Expected a function\");\n    const l = this.fst();\n    if (!l.concat) throwError(\"Pair: First value should be a Semigroup\");\n    const p = f(this.snd());\n    if (!(p instanceof Pair)) throwError(\"Pair: Function must return a Pair\");\n    const r = p.fst();\n    if (!r.concat)\n      throwError(\n        \"Pair: First value of the returned Pair should be a Semigroup\"\n      );\n\n    return new Pair(l.concat(r), p.snd());\n  }\n\n  swap() {\n    const v = this.getValue();\n    return new Pair(v[1], v[0]);\n  }\n\n  toString() {\n    const v = this.getValue();\n    return `Pair((${v[0]}), (${v[1]}))`;\n  }\n}\n\nexport default Pair;\nexport { _of };\n","import PairType, {_of} from \"./pair-type\"\n\nconst Pair: any = (v1: any, v2: any) => new PairType(v1, v2);\nPair.of = _of;\n\nexport default Pair;","import {Setoid, Monad, PatternMatch, BiFunctor} from \"../interfaces\";\nimport {throwError, isFunction} from \"../functions/helpers\";\n\nconst _lefts = new WeakMap();\nclass Left implements Setoid, BiFunctor, Monad, PatternMatch {\n\n    constructor(v: any){\n        _lefts.set(this, v);\n    }\n\n    equals(n: Setoid): boolean{\n       return n instanceof Left && n.isLeft && n.isLeft() && n.getValue() === this.getValue();\n    }\n\n    // isEqual(n: any){\n    //     return this.equals(n);\n    // }\n\n    of(v: any){\n        return new Left(v);\n    }\n\n    ap(n: Left){\n        return this;\n    }\n\n    getValue(){\n        return _lefts.get(this);\n    }\n\n    map(f: Function){\n        return this;\n    }\n\n    bimap(f: Function, _:Function): Left{\n        return this.of(f(this.getValue()))\n    }\n\n    chain(f: Function){\n        return this;\n    }\n\n    isRight(){\n        return false;\n    }\n\n    isLeft(){\n        return true;\n    }\n\n    swap(){\n        return new Right(this.getValue());\n    }\n\n    toString(){\n        return `Left(${this.getValue()})`;\n    }\n\n    caseOf(o: {Left: Function}){\n        return o.Left ? o.Left(this.getValue()) : throwError(\"Either: Expected Left!\");\n    }\n}\n\nconst _rights = new WeakMap();\nclass Right implements Setoid, BiFunctor, Monad, PatternMatch {\n\n    constructor(v: any){\n        _rights.set(this, v);\n    }\n\n    equals(j: Setoid): boolean{\n        return j instanceof Right && j.isRight && j.isRight() && j.getValue() === this.getValue();\n    }\n\n    // isEqual(n: any){\n    //     return this.equals(n);\n    // }\n\n    of(v: any){\n        return new Right(v);\n    }\n\n    ap(j: Right | Left): Right | Left{\n        if(!isFunction(j.getValue())) throwError(\"Either: Wrapped value is not a function\");\n        return this.map(j.getValue());\n    }\n\n    getValue(){\n        return _rights.get(this);\n    }\n\n    map(f: Function){\n        if(!isFunction(f)) throwError(\"Either: Expected a function\");\n        return new Right(f(this.getValue()));\n    }\n\n    bimap(_: Function, f:Function): Right{\n        return this.of(f(this.getValue()))\n    }\n\n    chain(f: Function){\n        if(!isFunction(f)) throwError(\"Either: Expected a function\");\n        return f(this.getValue());\n    }\n\n    isRight(){\n        return true;\n    }\n\n    isLeft(){\n        return false;\n    }\n\n    swap(){\n        return new Left(this.getValue());\n    }\n\n    toString(){\n        return `Right(${this.getValue()})`;\n    }\n\n    caseOf(o: {Right: Function}){\n        return o.Right ? o.Right(this.getValue()) : throwError(\"Either: Expected Right\");\n    }\n}\n\nconst Either = {\n    of: (v: any) => new Right(v),\n    Right: (v: any): Right => new Right(v),\n    Left: (v: any): Left => new Left(v),\n    fromNullable: (v: any): Right | Left => v ? new Right(v) : new Left(v),\n    withDefault: (def: any, v: any): Right => v ? new Right(v) : new Right(def),\n    swap: (e: Left | Right) => e.swap(),\n    try: (f: Function) => (...args: Array<any>) =>{\n        try {\n            return new Right(f.apply(null, args));\n        } catch (error) {\n            return new Left(error);\n        }\n    },\n    bimap: (e: Left | Right, fl: Function, fr: Function): Left | Right => e.bimap(fl, fr),\n    isLeft: (v: Left | Right) => v.isLeft && v.isLeft(),\n    isRight: (v: Left | Right) => v.isRight && v.isRight()\n}\n\n\nexport default Either;","// import Functor from \"../implements/functor\";\n// import Monad from \"../implements/monad\";\n// import PatternMatch from \"../implements/patternmatch\";\nimport { Setoid, Monad, PatternMatch } from \"../interfaces\";\nimport { throwError, isFunction } from \"../functions/helpers\";\n\nexport class Nothing implements Setoid, Monad, PatternMatch {\n  equals(n: Setoid): boolean {\n    return n instanceof Nothing && n.isNothing && n.isNothing();\n  }\n\n  // isEqual(n: Nothing){\n  //     return this.equals(n);\n  // }\n\n  of(v: any) {\n    return new Nothing();\n  }\n\n  ap(n: Nothing) {\n    return this;\n  }\n\n  getValue(): null {\n    return null;\n  }\n\n  map(f: Function) {\n    return this;\n  }\n\n  chain(f: Function) {\n    return this;\n  }\n\n  isJust() {\n    return false;\n  }\n\n  isNothing() {\n    return true;\n  }\n\n  toString() {\n    return \"Nothing()\";\n  }\n\n  caseOf(o: { Nothing: Function }) {\n    return o.Nothing ? o.Nothing() : throwError(\"Maybe: Expected Nothing!\");\n  }\n}\n\nconst _justs = new WeakMap();\nexport class Just implements Setoid, Monad, PatternMatch {\n  constructor(v: any) {\n    _justs.set(this, v);\n  }\n\n  equals(j: Setoid): boolean {\n    return (\n      j instanceof Just &&\n      j.isJust &&\n      j.isJust() &&\n      j.getValue() === this.getValue()\n    );\n  }\n\n  // isEqual(n: Just){\n  //     return this.equals(n);\n  // }\n\n  of(v: any) {\n    return new Just(v);\n  }\n\n  ap(j: Just | Nothing): Just | Nothing {\n    if (!isFunction(j.getValue()))\n      throwError(\"Maybe: Wrapped value is not a function\");\n    return this.map(j.getValue());\n  }\n\n  getValue(): any {\n    return _justs.get(this);\n  }\n\n  map(f: Function) {\n    if (!isFunction(f)) throwError(\"Maybe: Expected a function\");\n    return new Just(f(this.getValue()));\n  }\n\n  chain(f: Function) {\n    if (!isFunction(f)) throwError(\"Maybe: Expected a function\");\n    return f(this.getValue());\n  }\n\n  isJust() {\n    return true;\n  }\n\n  isNothing() {\n    return false;\n  }\n\n  toString() {\n    return `Just(${this.getValue()})`;\n  }\n\n  caseOf(o: { Just: Function }) {\n    return o.Just\n      ? o.Just(this.getValue())\n      : throwError(\"Maybe: Expected Just\");\n  }\n}\n\nconst Maybe = {\n  of: (v: any) => new Just(v),\n  zero: () => new Nothing(),\n  Just: (v: any): Just => new Just(v),\n  Nothing: (v?: any): Nothing => new Nothing(),\n  fromNullable: (v: any): Just | Nothing => (v ? new Just(v) : new Nothing()),\n  withDefault: (def: any, v: any): Just => (v ? new Just(v) : new Just(def)),\n  catMaybes: (ar: Array<Just | Nothing>): Array<any> =>\n    ar.filter(m => m instanceof Just).map(m => m.getValue()),\n  isJust: (v: Just | Nothing) => v.isJust(),\n  isNothing: (v: Just | Nothing) => v.isNothing()\n};\n\nexport default Maybe;\n","import { Monad, Semigroup } from \"../interfaces\";\nimport { once, compose, throwError, isFunction } from \"../functions/helpers\";\n\nconst _of = (v: any) => {\n  return new Task((_: any, resolve: Function) => resolve(v));\n};\n\nconst _rejected = (v: any) => {\n  return new Task((reject: Function, _: Function) => reject(v));\n};\n\nconst _tasks = new WeakMap();\nclass Task implements Semigroup, Monad {\n  constructor(f: Function) {\n    isFunction(f)\n      ? _tasks.set(this, f)\n      : throwError(\"Task: Expected a Function\");\n  }\n\n  fork(reject: Function, resolve: Function) {\n    if (!isFunction(resolve) || !isFunction(reject))\n      throwError(\"Task: Reject and Resolve need to be functions\");\n    const fn = this.getValue();\n    fn(reject, resolve);\n  }\n\n  of(v: any) {\n    return _of(v);\n  }\n\n  toString() {\n    const fork = this.getValue();\n    return `Task(${fork.name})`;\n  }\n\n  map(f: Function) {\n    if (!isFunction(f)) throwError(\"Task: Expected a function\");\n    const fork = this.getValue();\n    return new Task((rej: Function, res: Function) =>\n      fork(rej, compose(res, f))\n    );\n  }\n\n  getValue() {\n    return _tasks.get(this);\n  }\n\n  ap(t: Task) {\n    if (!(t instanceof Task)) throwError(\"Task: type mismatch\");\n    const thisFork = this.getValue();\n    let value: Array<any>;\n    let fn: Function;\n    let gotValues: boolean = false;\n    let gotFuction: boolean = false;\n    let rejected: boolean = false;\n\n    return new Task((rej: Function, res: Function) => {\n      const rejOnce = compose(() => {\n        rejected = true;\n      }, once(rej));\n\n      const resolveBoth = () => {\n        if (gotValues && gotFuction && !rejected) {\n          const exec = compose(res, fn);\n          exec.apply(null, value);\n        }\n      };\n\n      thisFork(rejOnce, (...values: Array<any>) => {\n        value = values;\n        gotValues = true;\n        resolveBoth();\n      });\n\n      t.fork(rejOnce, (f: Function) => {\n        if (!isFunction(f))\n          throwError(\"Task: Wrapped value should be a function\");\n        fn = f;\n        gotFuction = true;\n        resolveBoth();\n      });\n    });\n  }\n\n  concat(t: Task) {\n    if (!(t instanceof Task)) throwError(\"Task: type mismatch\");\n    const thisFork = this.getValue();\n    const thatFork = t.getValue();\n\n    return new Task((rej: Function, res: Function) => {\n      let rejected: boolean = false;\n      const rejOnce = compose(() => {\n        rejected = true;\n      }, once(rej));\n      let result1: any;\n      let result2: any;\n\n      const resolveBoth = () => {\n        if (result1 && result2 && !rejected) {\n          res.apply(null, [...result1, ...result2]);\n        }\n      };\n\n      thisFork(rejOnce, (...values: Array<any>) => {\n        result1 = values;\n        resolveBoth();\n      });\n\n      thatFork(rejOnce, (...values: Array<any>) => {\n        result2 = values;\n        resolveBoth();\n      });\n    });\n  }\n\n  chain(f: Function) {\n    if (!isFunction(f)) throwError(\"Task: Function required\");\n    const thisFork = this.getValue();\n\n    return new Task((rej: Function, res: Function) => {\n      thisFork(rej, (...args: Array<any>) => {\n        const t = f.call(null, args);\n        if (!(t instanceof Task))\n          throwError(\"Task: function must return another Task\");\n        t.fork(rej, res);\n      });\n    });\n  }\n\n  toPromise() {\n    const thisFork = this.getValue();\n    return new Promise((res, rej) => {\n      thisFork(rej, res);\n    });\n  }\n}\n\nexport default Task;\nexport { _of, _rejected };\n","import TaskType, {_of, _rejected} from \"./task-type\"\n\nconst Task: any = (f: Function) => new TaskType(f);\nTask.of = _of;\nTask.rejected = _rejected;\n\nexport default Task;","import {\n    id,\n    once,\n    fmap,\n    bimap,\n    chain,\n    caseOf,\n    curry,\n    ncurry,\n    compose,\n    liftAn,\n    liftA1,\n    liftA2,\n    liftA3,\n    liftA4,\n    liftA5\n} from \"./functions/helpers\"\n\n//Algebraic Data Types\nimport Pair from \"./data-types/pair\";\nimport Either from \"./data-types/either\";\nimport Maybe from \"./data-types/maybe\";\nimport Task from \"./data-types/task\";\n\nexport default {\n    id,\n    once,\n    fmap,\n    bimap,\n    chain,\n    caseOf,\n    curry,\n    ncurry,\n    compose,\n    liftAn,\n    liftA1,\n    liftA2,\n    liftA3,\n    liftA4,\n    liftA5,\n    Pair,\n    Either,\n    Maybe,\n    Task\n};\n"],"names":["slice","Array","prototype","throwError","x","id","isFunction","f","once","_called","_result","undefined","_i","apply","args","curry","fn","arity","length","call","arguments","curried","concat","ncurry","ar","curArgs","Object","keys","diff","filter","indexOf","ar2","assign","compose","fns","reduce","g","_fmap","map","fmap","_bimap","f1","f2","b","bimap","_chain","m","chain","_caseOf","o","p","caseOf","_liftAn","init","res","rest","a","ca","ap","_liftA1","_liftA2","_liftA3","f3","_liftA4","f4","_liftA5","f5","liftAn","liftA1","liftA2","liftA3","liftA4","liftA5","_of","v","Pair","_pairs","WeakMap","v1","v2","set","j","fst","snd","lf","ls","rf","rs","getValue","l","r","get","PairType","of","_lefts","n","Left","isLeft","_","Right","_rights","isRight","Either","def","e","swap","error","fl","fr","Nothing","isNothing","_justs","Just","isJust","Maybe","Task","resolve","_rejected","reject","_tasks","fork","name","rej","t","thisFork","value","gotValues","gotFuction","rejected","rejOnce","resolveBoth","exec","values","thatFork","result1","result2","Promise","TaskType"],"mappings":"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"}